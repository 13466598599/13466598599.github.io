{"meta":{"title":"任俊达的技术博客","subtitle":"","description":"","author":"任俊达","url":"https://renjunda.ren","root":"/"},"pages":[{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-07-01T10:04:51.744Z","comments":true,"path":"PY.html","permalink":"https://renjunda.ren/PY.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 我的朋友"},{"title":"BuyMeTea","date":"2002-04-01T01:23:02.000Z","updated":"2022-04-01T01:34:20.789Z","comments":true,"path":"money.html","permalink":"https://renjunda.ren/money.html","excerpt":"","text":"请我喝茶"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-10-31T01:42:11.798Z","comments":true,"path":"about.html","permalink":"https://renjunda.ren/about.html","excerpt":"","text":"我的画像我是不理性的、懒惰的、仅凭热爱驱动的、偏执的、信仰科学的、喜欢探索的、热爱生命的、向往阳光的。 我听的音乐老渔夫快乐吃虾米 - 用户 - 网易云音乐(163.com) 我的微信"}],"posts":[{"title":"如何用python实现自动下载自己想要的图片?","slug":"如何用python实现自动下载自己想要的图片","date":"2022-08-12T06:14:48.000Z","updated":"2022-08-12T06:37:45.725Z","comments":true,"path":"lxb/dcf0004f.html","link":"","permalink":"https://renjunda.ren/lxb/dcf0004f.html","excerpt":"","text":"关于python爬虫的优点——支持模块多、代码简洁、开发效率高 ，是我们进行网络爬虫可以选取的好工具。对于一个个的爬取下载，势必会消耗我们大量的时间，使用Python爬虫就可以解决这个问题，即可以实现自动下载。本文向大家介绍python爬虫的实战练习之进行自动下载图片的爬取过程。 自动下载图片流程 总结网址规律，以便根据网址访问网页； 根据网址规律，循环爬取并返回网页； 利用正则表达式提取并返回图片; 爬取案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding:utf8 -*-&#x27;&#x27;&#x27; 功能介绍： 利用爬虫实现图片爬取,输入你想检索的图片调用百度图片api实现检索,并下载文件&#x27;&#x27;&#x27;import requestsimport refrom urllib import parseimport osclass BaiduImageSpider(object): def __init__(self): self.url = &#x27;https://image.baidu.com/search/flip?tn=baiduimage&amp;word=&#123;&#125;&#x27; self.headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/4.0&#x27;&#125; # 获取图片 def get_image(self, url, word): # 使用 requests模块得到响应对象 res = requests.get(url, headers=self.headers) # 更改编码格式 res.encoding = &quot;utf-8&quot; # 得到html网页 html = res.text print(html) # 正则解析 pattern = re.compile(&#x27;&quot;hoverURL&quot;:&quot;(.*?)&quot;&#x27;, re.S) img_link_list = pattern.findall(html) # 存储图片的url链接 print(img_link_list) # 创建目录，用于保存图片 directory = &#x27;D:/study_folder/download/&#123;&#125;/&#x27;.format(word) # 如果目录不存在则创建，此方法常用 if not os.path.exists(directory): os.makedirs(directory) # 添加计数 i = 1 for img_link in img_link_list: filename = &#x27;&#123;&#125;&#123;&#125;.jpg&#x27;.format(directory, i) self.save_image(img_link, filename) i += 1 # 下载图片 def save_image(self, img_link, filename): html = requests.get(url=img_link, headers=self.headers).content with open(filename, &#x27;wb&#x27;) as f: f.write(html) print(filename, &#x27;下载成功&#x27;) # 入口函数 def run(self): word = input(&quot;您想要谁的照片:&quot;) word_parse = parse.quote(word) url = self.url.format(word_parse) self.get_image(url, word)if __name__ == &#x27;__main__&#x27;: spider = BaiduImageSpider() spider.run() 以上就是使用Python爬虫实现自动下载图片的过程，为了解放我们的双手，大家赶快练习起来哦~学会以后还可以往更深层次学呢，爬虫可不止是只能自动下载图片哦！","categories":[],"tags":[]},{"title":"函数内的ajax同步请求导致遮罩层失效、或者导致loading正在加载提示失效问题","slug":"ajax同步执行弹出层执行顺序混乱","date":"2022-08-02T05:57:35.000Z","updated":"2022-10-04T14:15:34.679Z","comments":true,"path":"lxb/416dd1e7.html","link":"","permalink":"https://renjunda.ren/lxb/416dd1e7.html","excerpt":"","text":"功能需求编写点击按钮，弹出loading遮罩层提示正在加载中…，同时查询后台信息，拼接数据后渲染到列表时，为了保障渲染时，列表中的数据已经拼接完成。所以在for循环中使用同步ajax进行请求，在success方法中进行拼接。 1234567891011121314151617181920212223function showPrintJobList()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); for(var i = 0;i &lt; rwid.length;i++)&#123; $.ajax(&#123; url: xxxxx, async: false, //默认异步，为保证数据完整和顺序使用同步请求 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //.....循环拼接结果，弹窗显示列表:$(&#x27;#rwlist&#x27;).show(); &#125;, error: function(err)&#123; console.log(err); &#125; &#125;); &#125; loadingTip.hide(); $(&#x27;#rwlist&#x27;).show();&#125; 问题信息点击按钮后，遮罩层没有弹出，而是等待表单渲染完成后，看到一闪而过的遮罩层。 问题原因async: falseajax同步请求在运行的时候，浏览器的UI、Dom元素渲染会被阻塞。所以当点击事件触发showPrintJobList函数时，loading.show()是有被加载到浏览器的js运行线程中，但是运行到ajax同步请求时，会将loading.show()阻塞执行，等到同步ajax请求完了，才会运行。然后同步ajax已经请求完了，然后直接被隐藏，然后显示列表。所以会看到一闪而过的loading遮罩层 解决方法一、使用async wait关键字二、使用JQuery的Deferred对象和$.when().done().fail() async&#x2F;await关键字 1.标识所修饰的函数存在异步代码，函数内部可用await关键字修饰异步过程变为同步。函数内部也可以全部为同步代码。2.非阻塞：async所标识的函数内存在异步代码，会等待异步代码执行完，但是async函数本身会马上返回，不会阻塞当前js工作主线程，可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回； 代码修改如下： 1234567891011121314151617181920212223async function showPrintJobList()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); for(var i = 0;i &lt; rwid.length;i++)&#123; await $.ajax(&#123; //使用await关键字修饰异步请求，保证数据顺序完整 url: xxxxx, async: true, //有await关键字，ajax请求修改为异步 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //.....循环拼接结果，弹窗显示列表:$(&#x27;#rwlist&#x27;).show(); &#125;, error: function(err)&#123; console.log(err); &#125; &#125;); &#125; loadingTip.hide(); $(&#x27;#rwlist&#x27;).show();&#125; 或者使用JQuery的Deferred对象和$.when().done().fail()使异步请求同步执行，同时不阻塞主线程。 123456789101112131415161718192021222324252627282930313233343536var dataList = [];function showPrintJobList()&#123; var defer = $.Deferred(); for(var i = 0;i &lt; rwid.length;i++)&#123; $.ajax(&#123; url: xxxxx, async: true, //使用Deferred对象，ajax请求修改为异步 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //dataList保存结果 dataList.push(result); defer.resolve(dataList); &#125;, error: function(err)&#123; defer.reject(err); &#125; &#125;); &#125; return defer;&#125;$(&#x27;button#showList&#x27;).click(function()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); $.when(showPrintJobList()).done(function(data)&#123; //循环拼接data中的list中的数据 loadingTip.hide(); $(&#x27;#rwlist&#x27;).show(); &#125;).fail(function()&#123; console.log(err); &#125;);&#125; 原理解析浏览器中一般会运行UI线程、JS线程以及事件触发线程。在上述上述代码中，loading.show()方法涉及到dom树的更新，所以被加载到了UI线程执行任务中。但是后面的ajax同步请求，因为不是异步的所以浏览器不会重新新增一个线程进行请求，而是直接放在js线程中阻塞其他线程执行。所以UI线程不能执行loading.show()方法。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"}]},{"title":"linux常用命令","slug":"linux常用命令/linux常用命令","date":"2022-07-15T08:00:00.000Z","updated":"2022-07-28T02:44:44.020Z","comments":true,"path":"lxb/fe4ef317.html","link":"","permalink":"https://renjunda.ren/lxb/fe4ef317.html","excerpt":"","text":"Linux随着IT产业的不断发展，Linux操作系统应用领域越来越广泛，尤其是近年来Linux在服务器领域飞速的发展，主要得益于Linux操作系统具备的如下优点 开源免费、系统迭代更新 系统性能稳定、安全性高 多任务、多用户 耗资源小、无需图形化界面、内核小 应用领域广泛、使用及入门容易 Linux命令cd12345目录切换cd .. # 上一层目录cd # 家目录cd ~ # 家目录cd / # 根目录 ls12345浏览目录下的文件或文件夹 ls -a # 列举所有文件或目录，包含.开头的隐藏文件 ls -l # 详细信息列举文件或目录 ls -i # 列出每个文件的Inode号 ls -t # 根据修改时间列出文件 pwd1显示当前所在的目录 mkdir123创建目录mkdir a # 创建a目录mkdir -p a/b/c # 递归创建目录 rm1234删除文件或目录rm a # 删除a文件rm -r a # 删除a目录rm -rf a # 强制删除a文件，不提示确认 cpcp 参数说明 -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。123拷贝文件或文件夹cp /root/1.py /home/1.py # 拷贝文件至新目录下cp -r 表示递归创建 cp -r 实例使用指令 cp 将当前目录 test&#x2F; 下的所有文件复制到新目录 newtest 下，输入如下命令： cp –r test&#x2F; newtest touch12创建普通文件touch 1.py # 创建1.py文件 cat1234查看文件内容cat /etc/redis/redis.conf # 查看redis.conf文件cat -n # 对输出所有行进行编号cat -b # 对输出非空行进行编号 cat1234查看文件内容cat /etc/redis/redis.conf # 查看redis.conf文件cat -n # 对输出所有行进行编号cat -b # 对输出非空行进行编号 less123如果文件较大的话，例如日志文件,我们想查看这个文件用cat命令肯定是不行的,less 命令可以精确到你想要查看的行号less -N + 行号 g run.log注意： -N是为了显示行号 head1234查看文件头部内容，通常为十行head -3 /etc/memcached.conf # 查看前三行head -n 100 # 查看前100行head -c 3 # 查看前三字节 tail1234查看文件末尾内容，通常为十行tail -n 3 1.txt # 查看后3行tail -f # 阻塞并即使输出文件变化后追加的数据用tail -f 监控日志日文件很方便,一定程度上可以提升开发效率 df123磁盘信息查询df -h # 查询磁盘使用量df -i # 分区Inode使用量 du12查看文件大小du -h 1.txt # 查看1.txt文件大小 echo1234打印或输出内容echo &#x27;hello&#x27; # 输出helloecho &#x27;hello&#x27; &gt; 1.md # 以hello内容覆盖1.mdecho &#x27;hello&#x27; &gt;&gt; 1.md # 以hello追加至1.md文件中 tar12345解压或压缩文件tar -jxvf # 解压bz2属性的压缩包tar -zxvf # 解压gz属性的压缩包tar -czvf # 使用gzip格式压缩文件tar -cjvf # 使用bzip2格式压缩文件 top1234567891011查看cpu使用率、内存使用率Processes: 602 total, 3 running, 599 sleeping, 3328 threads 10:28:56Load Avg: 2.28, 2.59, 2.93 CPU usage: 2.9% user, 2.3% sys, 95.87% idleSharedLibs: 433M resident, 88M data, 120M linkedit.MemRegions: 183414 total, 5692M resident, 133M private, 1890M shared.PhysMem: 16G used (3203M wired), 57M unused.VM: 20T vsize, 3083M framework vsize, 210327729(698) swapins, 212927606(0) swapouts.Networks: packets: 12467515/57G in, 10837863/53G out.Disks: 13084346/899G read, 9903101/930G written.PID COMMAND %CPU TIME #TH #WQ #PORT MEM PURG CMPRS PGRP PPID STATE free12345free -h查看内存，并以人性化方式展示[iomt@pa_cicd ~]$ free -h total used free shared buff/cache availableMem: 15G 1.1G 12G 313M 2.4G 13GSwap: 2.0G 0B 2.0G iostat1查看磁盘io读取速度 ps12查看进程ps -ef | grep process name su12切换账号su root # 切换为root用户 passwd1修改密码 rename1234567891011批量修改文件名称 &gt;[root@localhost kervin24]# ls a c fc.log ff.log fi.log fl.log fo.log fr.log fu.log fx.log aaa d fd.log fg.log fj.log fm.log fp.log fs.log fv.log fy.log b fb.log fe.log fh.log fk.log fn.log fq.log ft.log fw.log fz.log [root@localhost kervin24]# rename log txt * 把所有log文件改为txt文件 ------------------------------------------------------------------------------ [root@localhost kervin24]# ls a c fc.txt ff.txt fi.txt fl.txt fo.txt fr.txt fu.txt fx.txt aaa d fd.txt fg.txt fj.txt fm.txt fp.txt fs.txt fv.txt fy.txt b fb.txt fe.txt fh.txt fk.txt fn.txt fq.txt ft.txt fw.txt fz.txt","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://renjunda.ren/tags/Linux/"}]},{"title":"python详解paramiko","slug":"python详解paramiko/python详解paramiko","date":"2022-07-01T12:00:00.000Z","updated":"2022-07-28T02:44:26.154Z","comments":true,"path":"lxb/b2d1c38.html","link":"","permalink":"https://renjunda.ren/lxb/b2d1c38.html","excerpt":"","text":"paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。paramiko支持Linux, Solaris, BSD, MacOS X, Windows等平台通过SSH从一个平台连接到另外一个平台。利用该模块，可以方便的进行ssh连接和sftp协议进行sftp文件传输。 一、SSHClient类SSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装，该类封装了传输(Transport)，通道(Channel)及SFTPClient建立的方法(open_sftp)，通常用于执行远程命令。 ssh远程连接服务器 connet()1connect(ip, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False, sock=None, gss_auth=False, gss_kex=False, gss_deleg_creds=True, gss_host=None, banner_timeout=None, auth_timeout=None, gss_trust_dns=True, passphrase=None) 参数说明： ip(str类型)，连接的目标主机地址； port(int类型)，连接目标主机的端口，默认为22； username(str类型)，校验的用户名(默认为当前的本地用户名)； password(str类型)，密码用于身份校验或解锁私钥； pkey(Pkey类型)，私钥方式用于身份验证； key_filename(str or list(str)类型)，一个文件名或文件名列表，用于私钥的身份验证； timeout(float类型)，一个可选的超时时间(以秒为单位)的TCP连接； allow_agent(bool类型)，设置为False时用于禁用连接到SSH代理； look_for_keys(bool类型)，设置为False时用于来禁用在～&#x2F;.ssh中搜索私钥文件； compress(bool类型)，设置为True时打开压缩。 1234import paramikossh = paramiko.SSHClient()ssh.connect(ip,22,username,passwd,timeout=5)此处ip、username、passwd都作为变量 执行命令123456789101112131415import paramikoclient = paramiko.SSHClient()client.load_system_host_keys()# 目的是接受不在本地Known_host文件下的主机client.set_missing_host_key_policy(paramiko.AutoAddPolicy())# connect 函数可以接受很多参数client.connect(ip, port, txt_username, txt_password, timeout=5, allow_agent=False, look_for_keys=False)remote_conn = client.invoke_shell()time.sleep(3)# 实现当前目录下的东西remote_conn.send(&#x27;ls\\n&#x27;)# 获取命令的执行结果output = remote_conn.recv(2065535)# 关闭连接client.close()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"}]},{"title":"Mysql取消外键约束","slug":"Mysql取消外键约束","date":"2022-04-25T15:16:12.000Z","updated":"2022-04-28T10:16:36.488Z","comments":true,"path":"lxb/a03a2ff4.html","link":"","permalink":"https://renjunda.ren/lxb/a03a2ff4.html","excerpt":"","text":"SET FOREIGN_KEY_CHECKS&#x3D;0;在Mysql中取消外键约束Mysql中如果表和表之间建立的外键约束，则无法删除表及修改表结构 解决方法是在Mysql中取消外键约束: SET FOREIGN_KEY_CHECKS&#x3D;0; 然后将原来表的数据导出到sql语句，重新创建此表后，再把数据使用sql导入 然后再设置外键约束: SET FOREIGN_KEY_CHECKS&#x3D;1;","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://renjunda.ren/tags/Mysql/"}]},{"title":"使用chmod修改权限","slug":"使用chmod修改权限","date":"2022-04-21T08:16:12.000Z","updated":"2022-04-28T10:12:32.284Z","comments":true,"path":"lxb/26c8ee4c.html","link":"","permalink":"https://renjunda.ren/lxb/26c8ee4c.html","excerpt":"","text":"chmod简介12Chmod命令主要用于修改、设置文件权限chmod 修改文件权限主要有两种方式： 字母法与数字法 chmod能改变权限，-R是目录下所有文件，777就是高权限（读、写、执行）chmod -R 777 * 意思就是将当前目录下所有文件都给予777权限 1234567-rw------- （600) – 只有属主有读写权限。-rw-r–r-- (644) – 只有属主有读写权限；而属组用户和其他用户只有读权限。-rwx------ (700) – 只有属主有读、写、执行权限。-rwxr-xr-x (755) – 属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx–x–x (711) – 属主有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw-rw-rw- (666) – 所有用户都有文件读、写权限。这种做法不可取。-rwxrwxrwx (777) – 所有用户都有读、写、执行权限。更不可取的做法。 u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。u用户 g组 o其它 a 所有用户(默认) 表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 这个在服务器里不能随便敲的，不能在根目录下进行此命令，因为有些进程是指定权限（如755、700…）才能运行的…所以会出错.所以只需要指定自己所需的目录或文件进行赋予权限即可","categories":[],"tags":[]},{"title":"详解Python中的eval函数","slug":"详解Python中的eval函数","date":"2022-04-07T08:16:12.000Z","updated":"2022-04-08T03:39:53.752Z","comments":true,"path":"lxb/29f18618.html","link":"","permalink":"https://renjunda.ren/lxb/29f18618.html","excerpt":"","text":"在 Python 学习中如果能够利用好 Python 自带的函数，那么开发的速度将会出现事半功倍的效果。 一直以来关于 eval 函数的用法不是很清楚，毕竟这个函数在开发中出现的频率不算高。但是详细了解 eval 函数的用法，也是很重要的 实战教程 综上所述:eval函数的用法就是把字符串对象转换为能够具体的对象.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://renjunda.ren/tags/python/"}]},{"title":"Djano实现下载文件功能 (你没事吧?😁)","slug":"Djano实现下载文件功能/Djano实现下载文件功能","date":"2022-04-01T09:00:21.000Z","updated":"2022-04-02T01:12:18.838Z","comments":true,"path":"lxb/6c2328a8.html","link":"","permalink":"https://renjunda.ren/lxb/6c2328a8.html","excerpt":"","text":"一、简单介绍文件下载最简单的文件下载功能的实现 1、将文件流放入HttpResponse对象即可，如 12345def file_download(request): # do something... with open(&#x27;file_name.txt&#x27;) as f: c = f.read() return HttpResponse(c) 这种方式简单粗暴，适合小文件的下载，但如果这个文件非常大，这种方式会占用大量的内存，甚至导致服务器崩溃 更合理的文件下载功能Django的HttpResponse对象允许将迭代器作为传入参数，将上面代码中的传入参数c换成一个迭代器，便可以将上述下载功能优化为对大小文件均适合；而Django更进一步，推荐使StreamingHttpResponse对象取代HttpResponse对象，StreamingHttpResponse对象用于将文件流发送给浏览器，与HttpResponse对象非常相似，对于文件下载功能，使用StreamingHttpResponse对象更合理。 因此，更加合理的文件下载功能，应该先写一个迭代器，用于处理文件，然后将这个迭代器作为参数传递给StreaminghttpResponse对象 HttpResponse会直接使用迭代器对象，将迭代器对象的内容存储城字符串，然后返回给客户端，同时释放内存。可以当文件变大看出这是一个非常耗费时间和内存的过程。StreamingHttpResponse这是一种非常省时省内存的方法。但是因为StreamingHttpResponse的文件传输过程持续在整个response的过程中，所以这有可能会降低服务器的性能。 代码块 123456789101112131415from django.http import StreamingHttpResponse def file_download(request): def file_iterator(file_name, chunk_size=512): with open(file_name) as f: while True: c = f.read(chunk_size) if c: yield c else: break the_file_name = &quot;file_name.txt&quot; response = StreamingHttpResponse(file_iterator(the_file_name)) return response 结合项目使用完整示例代码如下，根据自己需求整改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 导入相关依赖文件import xlsxwriterfrom django.http import StreamingHttpResponse, JsonResponse, FileResponsefrom django.http import HttpResponsefrom django.urls import reverse_lazyfrom django.utils.encoding import escape_uri_pathdef export_data(request): filename = &#x27;&#123;&#125;.xlsx&#x27;.format(&#x27;人员信息&#x27;) if request.method == &#x27;GET&#x27;: try: response = StreamingHttpResponse(file_iterator(filename)) # 以流的形式下载文件,这样可以实现任意格式的文件下载 response[&#x27;Content-Type&#x27;] = &#x27;application/octet-stream&#x27; response[&quot;Content-Disposition&quot;] = &quot;attachment; filename*=UTF-8&#x27;&#x27;&#123;&#125;&quot;.format(escape_uri_path(filename)) except: return HttpResponse(&quot;生成文件失败&quot;) return response if request.method == &#x27;POST&#x27;: # 表头,为了方便直接再代码中, 平时我们为了规范代码一般写在配置文件中 ping_header = &#123; &#x27;姓名&#x27;: &#x27;1&#x27;, &#x27;性别&#x27;: &#x27;2&#x27;, &#x27;年龄&#x27;: &#x27;3&#x27;, &#x27;居住地址&#x27;: &#x27;4&#x27;, &#125; # 先把数据写死，根据需求自己去数据库查询 data = [ &#123;&#x27;name&#x27;: &#x27;刘备&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 18, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;关羽&#x27;, &#x27;sex&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;张飞&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;黄宇恒&#x27;, &#x27;sex&#x27;: &#x27;其他&#x27;, &#x27;age&#x27;: 99, &#x27;addr&#x27;: &#x27;江西省南昌市进贤县&#x27;&#125;, ] workbook = xlsxwriter.Workbook(filename) # 建立文件 worksheet = workbook.add_worksheet(&quot;人员信息统计&quot;) head_style = workbook.add_format(xlsx_style(bold=True, bg_color=&#x27;#95B3D7&#x27;)) body_style = workbook.add_format(xlsx_style()) _header = ping_header for index, value in enumerate(_header): worksheet.write(0, index + 4, value, head_style) n_index = 1 if len(data) &gt; 0: for item in data: worksheet.write(n_index, 4, item[&#x27;name&#x27;] if item.get(&#x27;name&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 5, item[&#x27;sex&#x27;] if item.get(&#x27;sex&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 6, item[&#x27;age&#x27;] if item.get(&#x27;age&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 7, item[&#x27;addr&#x27;] if item.get(&#x27;addr&#x27;) else &#x27;&#x27;, body_style) n_index += 1 # 将生成的excel放入byte流给response workbook.close() url = reverse_lazy(&#x27;app_name:路由名称&#x27;) # 将下载路由返回前端,前端通过请求返回的路由实现文件下载 return JsonResponse(&#123;&#x27;redirect&#x27;: url, &#x27;code&#x27;: 0&#125;)def file_iterator(file_path, chunk_size=512): &quot;&quot;&quot; 文件生成器,防止文件过大，导致内存溢出 :param file_path: 文件路径 :param chunk_size: 块大小 :return: 生成器 &quot;&quot;&quot; with open(file_path, mode=&#x27;rb&#x27;) as f: while True: c = f.read(chunk_size) if c: yield c else: break# xlsxwriter的样式公有函数def xlsx_style(**kwargs): style = &#123; &#x27;bold&#x27;: kwargs.get(&#x27;bold&#x27;, False), # 加粗 &#x27;font_name&#x27;: kwargs.get(&#x27;font_name&#x27;, &#x27;SimSun&#x27;), # 字体类型，默认宋体 &#x27;font_size&#x27;: kwargs.get(&#x27;font_size&#x27;, 10), # 字体大小，默认12 &#x27;font_color&#x27;: kwargs.get(&#x27;font_color&#x27;, &#x27;#000000&#x27;), # 字体颜色，黑色 &#x27;align&#x27;: kwargs.get(&#x27;align&#x27;, &#x27;center&#x27;), # 默认水平居中 &#x27;valign&#x27;: kwargs.get(&#x27;valign&#x27;, &#x27;vcenter&#x27;), # 默认垂直居中 &#x27;text_wrap&#x27;: kwargs.get(&#x27;text_wrap&#x27;, True), # 默认自动换行 &#x27;top&#x27;: kwargs.get(&#x27;top&#x27;, 1), # 上边界，线条宽度 &#x27;bottom&#x27;: kwargs.get(&#x27;bottom&#x27;, 1), # 边界 &#x27;left&#x27;: kwargs.get(&#x27;left&#x27;, 1), # 边界 &#x27;right&#x27;: kwargs.get(&#x27;right&#x27;, 1), # 边界 &#x27;bg_color&#x27;: kwargs.get(&#x27;bg_color&#x27;, &#x27;#FFFFFF&#x27;), # 背景颜色，白色 # 其他类型设置格式可以接着写 &#125; return style 文件下载完成后样式展示","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"js如何获取url中的参数","slug":"js如何获取url中的参数/js如何获取url中的参数","date":"2022-04-01T08:24:09.000Z","updated":"2022-04-02T01:10:09.079Z","comments":true,"path":"lxb/5477648b.html","link":"","permalink":"https://renjunda.ren/lxb/5477648b.html","excerpt":"","text":"js如何通过代码获取url中的参数, 以下函数是获取url中参数的公有方法, 直接使用即可123456789101112131415161718function getRequest() &#123; var url = window.location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; //就是这句的问题 theRequest[strs[i].split(&quot;=&quot;)[0]]=decodeURI(strs[i].split(&quot;=&quot;)[1]); //之前用了unescape() //才会出现乱码 &#125; &#125; return theRequest; &#125; var arr = getRequest(); var name = arr[&#x27;name&#x27;]; // url中的参数名称 var time = arr[&#x27;time&#x27;];","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"}]},{"title":"WebSocket连接失败，报错400","slug":"WebSocket连接失败，报错400/WebSocket连接失败，报错400","date":"2022-04-01T08:09:17.000Z","updated":"2022-04-01T08:21:19.994Z","comments":true,"path":"lxb/14b1fd40.html","link":"","permalink":"https://renjunda.ren/lxb/14b1fd40.html","excerpt":"","text":"WebSocket 连接失败，报错400 WebSocket握手期间出错，响应码：400。出现原因：可能你的应用程序版本低于nginx 我的解决方式：告诉nginx在和服务端通信的时候，使用http&#x2F;1.1，并且Nginx当想要使用WebSocket时由浏览器通过HTTP发起的Upgrade请求做出响应。即：在nginx的配置文件中，修改对应的websocket代理服务。如图： 修改完配置还需要再Django项目中的settings中配置websocket 1WEBSOCKET_FACTORY_CLASS = &#x27;dwebsocket.backends.uwsgi.factory.uWsgiWebSocketFactory&#x27; 最后重启nginx&amp;项目","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"}]},{"title":"layui弹出层时间控件闪退解决方案","slug":"layui弹出层时间控件闪退解决方案","date":"2021-04-01T07:53:58.000Z","updated":"2022-04-01T08:06:18.108Z","comments":true,"path":"lxb/d2cfb4a5.html","link":"","permalink":"https://renjunda.ren/lxb/d2cfb4a5.html","excerpt":"","text":"使用layui时间组件有闪退问题,只需要在实例化时添加点击事件问题就可以解决了,具体配置如下123456laydate.render(&#123; elem: &#x27;&#x27;, range: &#x27;到&#x27;, type: &#x27;datetime&#x27;, trigger: &#x27;click&#x27;, # 新增点击事件 &#125;);","categories":[],"tags":[{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"}]},{"title":"Django模糊查询和查询操作","slug":"Django模糊查询和查询操作","date":"2021-03-23T05:59:08.000Z","updated":"2022-03-30T10:00:02.501Z","comments":true,"path":"lxb/undefined.html","link":"","permalink":"https://renjunda.ren/lxb/undefined.html","excerpt":"","text":"Django ORM 模糊查询和查询操作queryset中支持链式操作12book=Book.objects.all().order_by(&#x27;-nid&#x27;).first()只要返回的是queryset对象就可以调用其他的方法,直到返回的是对象本身 模糊查询常用的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344大于、大于等于:__gt 大于&gt;__gte 大于等于&gt;=Student.objects.filter(age__gt=10) // 查询年龄大于10岁的学生Student.objects.filter(age__gte=10) // 查询年龄大于等于10岁的学生like:__exact 精确等于 like &#x27;aaa&#x27;__iexact 精确等于 忽略大小写 ilike &#x27;aaa&#x27;__contains 包含 like &#x27;%aaa%&#x27;__icontains 包含,忽略大小写 ilike &#x27;%aaa%&#x27;，但是对于sqlite来说，contains的作用效果等同于icontainsin:__in查询年龄在某一范围的学生Student.objects.filter(age__in=[10, 20, 30])is null / is not nullStudent.objects.filter(name__isnull=True) // 查询用户名为空的学生Student.objects.filter(name__isnull=False) // 查询用户名不为空的学生不等于/不包含于：Student.objects.filter().excute(age=10) // 查询年龄不为10的学生Student.objects.filter().excute(age__in=[10, 20]) // 查询年龄不在 [10, 20] 的学生其他常用模糊查询：__startswith 以…开头__istartswith 以…开头 忽略大小写__endswith 以…结尾__iendswith 以…结尾，忽略大小写__range 在…范围内__year 日期字段的年份__month 日期字段的月份__day 日期字段的日Book.objects.filter(create_time__year=2019, create_time__month=4).all()","categories":[],"tags":[]},{"title":"怎样实现图片验证码","slug":"怎样实现图片验证码","date":"2020-05-31T06:22:05.000Z","updated":"2022-04-02T07:35:15.805Z","comments":true,"path":"lxb/49696.html","link":"","permalink":"https://renjunda.ren/lxb/49696.html","excerpt":"","text":"利用django + vue实现图片验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import uuidimport randomfrom captcha.image import ImageCaptchafrom io import BytesIOimport redis# 创建redis实例r = redis.Redis(host=&#x27;127.0.0.1&#x27;, port=6379, password=&#x27;&#x27;,decode_responses=True)# 封装一个函数,此函数用于生成图片验证码中的数字或字母def random_code(num=4): # num 是生成随机的数量 默认为4 str__a_z = [chr(num) for num in range(97, 123)] str__A_Z = [chr(num) for num in range(65, 91)] num_0_9 = [str(num) for num in range(0, 10)] return &#x27;&#x27;.join(random.sample(str__a_z + str__A_Z + num_0_9, num))# 此函数用于生成图片def make_verify_image(code_str, uuid=None): # 保存验证码到redis中,并且设置过期时间 r.set(uuid, code_str, 60) # 生成验证码图片 img = ImageCaptcha().generate_image(code_str) # 图片不会永久存储，只需要在内存中存储即可 # 把Image对象写入到IO流中 out = BytesIO() # 文件流对象打开在内存中 img.save(out, &#x27;jpeg&#x27;) return out.getvalue()# vue代码 generate_image_code() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, UUId() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, jc() &#123; axios(&#123; url:this.base_url + &#x27;userapp/xy/&#x27;, method:&#x27;post&#x27;, data:&#123;&#x27;uuid&#x27;:this.uuid,&#x27;code&#x27;:this.check&#125; &#125;).then(res=&gt;&#123; console.log(res.data) if(res.data.code == 200) &#123; this.check_img = true this.error_image_code = res.data.msg &#125; if(res.data.code==500) &#123; this.check_img = false this.error_image_code = res.data.msg &#125; &#125;) &#125;,class GenerateUUID(APIView): def get(self, request): # 注册页面 挂载时请求接口 返回一个uuid rt = random_code() # print(rt) return Response(str(uuid.uuid1()))class Generateimg(APIView): &#x27;&#x27;&#x27; 返回前端验证码图片 &#x27;&#x27;&#x27; def get(self, request, uuid): # 2.创建随机数 code = random_code() # 3.生成验证码图片 image = make_verify_image(code, uuid) # 4.返回图片 return HttpResponse(image, content_type=&#x27;image/jpeg&#x27;)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"怎样设置flask后台管理","slug":"怎样设置flask后台管理","date":"2019-06-03T02:44:47.000Z","updated":"2022-04-08T03:39:59.325Z","comments":true,"path":"lxb/25760.html","link":"","permalink":"https://renjunda.ren/lxb/25760.html","excerpt":"","text":"快速开发后台flask-admin Flask-admin也是有局限性的,他只适合开发小型快速应用,不适合那种大型并发性高,逻辑复杂的应用. 首先,对于大型应用都是前后端分离的,加快访问速度,而且后端装配,尤其是这种动态生成的速度更慢 流程介绍1234567891011121314# 导入admin扩展包from flask_admin import Admin# 创建实例对象 这里的name就是后台的标题admin = Admin(app, name=&#x27;管理后台&#x27;, template_mode=&#x27;bootstrap3&#x27;) # 导入ModelViewfrom flask_admin.contrib.sqla import ModelView# 注册model public是声明的model类名 db.session,是在config中声明的数据库连接 name是小标题admin.add_view(ModelView(public, db.session,name=&#x27;test&#x27;))# 汉化 引入Flask-BabeIExfrom flask_babelex import Babelbabel = Babel(app)app.config[&#x27;BABEL_DEFAULT_LOCALE&#x27;] = &#x27;zh_CN&#x27; 大功告成!!","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]},{"title":"部署时django没有样式解决方案","slug":"部署时django没有样式解决方案","date":"2018-08-01T00:08:09.000Z","updated":"2022-04-02T07:44:04.381Z","comments":true,"path":"lxb/17098.html","link":"","permalink":"https://renjunda.ren/lxb/17098.html","excerpt":"","text":"我们在服务器上部署自己的项目时,发现django没有样式,这时我们需要收集静态资源来进行解决. 在项目中创建一个static文件夹 在settings中添加以下配置: 1STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;) 然后在nginx配置中添加 123location /static/ &#123; root /home/myproject/WorkerOrder; # 项目的绝对路径&#125; 配置完成后执行python manage.py collectstatic 重新启动nginx完毕","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"},{"name":"Linux","slug":"Linux","permalink":"https://renjunda.ren/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"},{"name":"Mysql","slug":"Mysql","permalink":"https://renjunda.ren/tags/Mysql/"},{"name":"python","slug":"python","permalink":"https://renjunda.ren/tags/python/"},{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"},{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"},{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"},{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]}