{"meta":{"title":"任俊达-技术博客","subtitle":"","description":"","author":"任俊达","url":"https://renjunda.ren","root":"/"},"pages":[{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-03-31T06:29:47.284Z","comments":true,"path":"PY.html","permalink":"https://renjunda.ren/PY.html","excerpt":"","text":"我的朋友"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-03-31T09:32:27.103Z","comments":true,"path":"about.html","permalink":"https://renjunda.ren/about.html","excerpt":"","text":"我的画像我是不理性的、懒惰的、仅凭热爱驱动的、偏执的、信仰科学的、喜欢探索的、热爱生命的、向往阳光的。 我听的音乐细腰婆姨 - 用户 - 网易云音乐(163.com)"}],"posts":[{"title":"Django模糊查询和查询操作","slug":"Django模糊查询和查询操作","date":"2021-03-23T05:59:08.000Z","updated":"2022-03-30T10:00:02.501Z","comments":true,"path":"lxb/undefined.html","link":"","permalink":"https://renjunda.ren/lxb/undefined.html","excerpt":"","text":"Django ORM 模糊查询和查询操作queryset中支持链式操作12book=Book.objects.all().order_by(&#x27;-nid&#x27;).first()只要返回的是queryset对象就可以调用其他的方法,直到返回的是对象本身 模糊查询常用的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344大于、大于等于:__gt 大于&gt;__gte 大于等于&gt;=Student.objects.filter(age__gt=10) // 查询年龄大于10岁的学生Student.objects.filter(age__gte=10) // 查询年龄大于等于10岁的学生like:__exact 精确等于 like &#x27;aaa&#x27;__iexact 精确等于 忽略大小写 ilike &#x27;aaa&#x27;__contains 包含 like &#x27;%aaa%&#x27;__icontains 包含,忽略大小写 ilike &#x27;%aaa%&#x27;，但是对于sqlite来说，contains的作用效果等同于icontainsin:__in查询年龄在某一范围的学生Student.objects.filter(age__in=[10, 20, 30])is null / is not nullStudent.objects.filter(name__isnull=True) // 查询用户名为空的学生Student.objects.filter(name__isnull=False) // 查询用户名不为空的学生不等于/不包含于：Student.objects.filter().excute(age=10) // 查询年龄不为10的学生Student.objects.filter().excute(age__in=[10, 20]) // 查询年龄不在 [10, 20] 的学生其他常用模糊查询：__startswith 以…开头__istartswith 以…开头 忽略大小写__endswith 以…结尾__iendswith 以…结尾，忽略大小写__range 在…范围内__year 日期字段的年份__month 日期字段的月份__day 日期字段的日Book.objects.filter(create_time__year=2019, create_time__month=4).all()","categories":[],"tags":[]},{"title":"怎样实现图片验证码","slug":"怎样实现图片验证码","date":"2020-05-31T06:22:05.000Z","updated":"2022-03-30T09:45:45.340Z","comments":true,"path":"lxb/49696.html","link":"","permalink":"https://renjunda.ren/lxb/49696.html","excerpt":"","text":"利用django + vue实现图片验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import uuidimport randomfrom captcha.image import ImageCaptchafrom io import BytesIOimport redis# 创建redis实例r = redis.Redis(host=&#x27;127.0.0.1&#x27;, port=6379, password=&#x27;&#x27;,decode_responses=True)# 封装一个函数,此函数用于生成图片验证码中的数字或字母def random_code(num=4): # num 是生成随机的数量 默认为4 str__a_z = [chr(num) for num in range(97, 123)] str__A_Z = [chr(num) for num in range(65, 91)] num_0_9 = [str(num) for num in range(0, 10)] return &#x27;&#x27;.join(random.sample(str__a_z + str__A_Z + num_0_9, num))# 此函数用于生成图片def make_verify_image(code_str, uuid=None): # 保存验证码到redis中,并且设置过期时间 r.set(uuid, code_str, 60) # 生成验证码图片 img = ImageCaptcha().generate_image(code_str) # 图片不会永久存储，只需要在内存中存储即可 # 把Image对象写入到IO流中 out = BytesIO() # 文件流对象打开在内存中 img.save(out, &#x27;jpeg&#x27;) return out.getvalue()# vue代码 generate_image_code() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, UUId() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, jc() &#123; axios(&#123; url:this.base_url + &#x27;userapp/xy/&#x27;, method:&#x27;post&#x27;, data:&#123;&#x27;uuid&#x27;:this.uuid,&#x27;code&#x27;:this.check&#125; &#125;).then(res=&gt;&#123; console.log(res.data) if(res.data.code == 200) &#123; this.check_img = true this.error_image_code = res.data.msg &#125; if(res.data.code==500) &#123; this.check_img = false this.error_image_code = res.data.msg &#125; &#125;) &#125;,class GenerateUUID(APIView): def get(self, request): # 注册页面 挂载时请求接口 返回一个uuid rt = random_code() # print(rt) return Response(str(uuid.uuid1()))class Generateimg(APIView): &#x27;&#x27;&#x27; 返回前端验证码图片 &#x27;&#x27;&#x27; def get(self, request, uuid): # 2.创建随机数 code = random_code() # 3.生成验证码图片 image = make_verify_image(code, uuid) # 4.返回图片 return HttpResponse(image, content_type=&#x27;image/jpeg&#x27;)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"怎样设置flask后台管理","slug":"怎样设置flask后台管理","date":"2019-06-03T02:44:47.000Z","updated":"2022-03-30T10:04:09.123Z","comments":true,"path":"lxb/25760.html","link":"","permalink":"https://renjunda.ren/lxb/25760.html","excerpt":"","text":"快速开发后台flask-admin Flask-admin也是有局限性的,他只适合开发小型快速应用,不适合那种大型并发性高,逻辑复杂的应用. 首先,对于大型应用都是前后端分离的,加快访问速度,而且后端装配,尤其是这种动态生成的速度更慢 流程介绍1234567891011121314# 导入admin扩展包from flask_admin import Admin# 创建实例对象 这里的name就是后台的标题admin = Admin(app, name=&#x27;管理后台&#x27;, template_mode=&#x27;bootstrap3&#x27;) # 导入ModelViewfrom flask_admin.contrib.sqla import ModelView# 注册model public是声明的model类名 db.session,是在config中声明的数据库连接 name是小标题admin.add_view(ModelView(public, db.session,name=&#x27;test&#x27;))# 汉化 引入Flask-BabeIExfrom flask_babelex import Babelbabel = Babel(app)app.config[&#x27;BABEL_DEFAULT_LOCALE&#x27;] = &#x27;zh_CN&#x27; 大功告成!!","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]},{"title":"部署时django没有样式解决方案","slug":"部署时django没有样式解决方案","date":"2018-08-01T00:08:09.000Z","updated":"2022-03-30T09:45:45.342Z","comments":true,"path":"lxb/17098.html","link":"","permalink":"https://renjunda.ren/lxb/17098.html","excerpt":"","text":"我们在服务器上部署自己的项目时,发现django没有样式,这时我们需要收集静态资源来进行解决. 在项目中创建一个static文件夹 在settings中添加以下配置: 1STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;) 然后在nginx配置中添加 123location /static/ &#123; root /home/myproject/WorkerOrder; # 项目的绝对路径&#125; 配置完成后执行python manage.py collectstatic 重新启动nginx完毕","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"},{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]}