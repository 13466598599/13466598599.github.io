{"meta":{"title":"任俊达的技术博客","subtitle":"","description":"","author":"任俊达","url":"https://renjunda.ren","root":"/"},"pages":[{"title":"BuyMeTea","date":"2002-04-01T01:23:02.000Z","updated":"2022-04-01T01:34:20.789Z","comments":true,"path":"money.html","permalink":"https://renjunda.ren/money.html","excerpt":"","text":"请我喝茶"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-07-01T10:04:51.744Z","comments":true,"path":"PY.html","permalink":"https://renjunda.ren/PY.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 我的朋友"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-10-31T01:42:11.798Z","comments":true,"path":"about.html","permalink":"https://renjunda.ren/about.html","excerpt":"","text":"我的画像我是不理性的、懒惰的、仅凭热爱驱动的、偏执的、信仰科学的、喜欢探索的、热爱生命的、向往阳光的。 我听的音乐老渔夫快乐吃虾米 - 用户 - 网易云音乐(163.com) 我的微信"}],"posts":[{"title":"Python操作MySQL如何获取插入数据的主键id","slug":"pymysql主键操作","date":"2023-01-12T01:18:15.000Z","updated":"2023-01-12T01:24:46.067Z","comments":true,"path":"lxb/ab8b976.html","link":"","permalink":"https://renjunda.ren/lxb/ab8b976.html","excerpt":"","text":"获取插入数据的主键id12345678910111213141516import pymysql database = pymysql.connect( host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, password=&quot;root&quot;, database=&quot;test&quot;)cursor = database.cursor() for i in range(5): cursor.execute(&#x27;insert into test (name) values (&quot;test&quot;)&#x27;) print(database.insert_id()) database.commit() cursor.close()database.close() 通过db.insert_id()方法可以获取插入数据的主键id, 注意一定要在commit之前获取,否则返回0。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"}]},{"title":"python线程池及其工作原理","slug":"python线程","date":"2023-01-01T00:16:12.000Z","updated":"2023-01-12T01:21:20.982Z","comments":true,"path":"lxb/7fe8f015.html","link":"","permalink":"https://renjunda.ren/lxb/7fe8f015.html","excerpt":"","text":"系统启动一个新线程的成本是比较高的，因为它涉及与操作系统的交互。在这种情形下，使用线程池可以很好地提升性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。 线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。 此外，使用线程池可以有效地控制系统中并发线程的数量。当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。 线程池的使用线程池的基类是 concurrent.futures 模块中的 Executor，Executor 提供了两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor，其中 ThreadPoolExecutor 用于创建线程池，而 ProcessPoolExecutor 用于创建进程池。 如果使用线程池&#x2F;进程池来管理并发编程，那么只要将相应的 task 函数提交给线程池&#x2F;进程池，剩下的事情就由线程池&#x2F;进程池来搞定。 Exectuor 提供了如下常用方法： submit(fn, *args, *kwargs)：将 fn 函数提交给线程池。args 代表传给 fn 函数的参数，*kwargs 代表以关键字参数的形式为 fn 函数传入参数。 map(func, *iterables, timeout&#x3D;None, chunksize&#x3D;1)：该函数类似于全局函数 map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。 shutdown(wait&#x3D;True)：关闭线程池。 程序将 task 函数提交（submit）给线程池后，submit 方法会返回一个 Future 对象，Future 类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步方式执行，因此，线程执行的函数相当于一个“将来完成”的任务，所以 Python 使用 Future 来代表。 1实际上，在 Java 的多线程编程中同样有 Future，此处的 Future 与 Java 的 Future 大同小异。 Future 提供了如下方法： cancel()：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。 cancelled()：返回 Future 代表的线程任务是否被成功取消。 running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。 done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。 result(timeout&#x3D;None)：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。 exception(timeout&#x3D;None)：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。 add_done_callback(fn)：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数。 在用完一个线程池后，应该调用该线程池的 shutdown() 方法，该方法将启动线程池的关闭序列。调用 shutdown() 方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。 使用线程池来执行线程任务的步骤如下： 调用 ThreadPoolExecutor 类的构造器创建一个线程池。 定义一个普通函数作为线程任务。 调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。 当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。 下面程序示范了如何使用线程池来执行线程任务: 12345678910111213141516171819202122232425262728from concurrent.futures import ThreadPoolExecutorimport threadingimport time# 定义一个准备作为线程任务的函数def action(max): my_sum = 0 for i in range(max): print(threading.current_thread().name + &#x27; &#x27; + str(i)) my_sum += i return my_sum# 创建一个包含2条线程的线程池pool = ThreadPoolExecutor(max_workers=2)# 向线程池提交一个task, 50会作为action()函数的参数future1 = pool.submit(action, 50)# 向线程池再提交一个task, 100会作为action()函数的参数future2 = pool.submit(action, 100)# 判断future1代表的任务是否结束print(future1.done())time.sleep(3)# 判断future2代表的任务是否结束print(future2.done())# 查看future1代表的任务返回的结果print(future1.result())# 查看future2代表的任务返回的结果print(future2.result())# 关闭线程池pool.shutdown() 上面程序中，第 13 行代码创建了一个包含两个线程的线程池，接下来的两行代码只要将 action() 函数提交（submit）给线程池，该线程池就会负责启动线程来执行 action() 函数。这种启动线程的方法既优雅，又具有更高的效率。 当程序把 action() 函数提交给线程池时，submit() 方法会返回该任务所对应的 Future 对象，程序立即判断 futurel 的 done() 方法，该方法将会返回 False（表明此时该任务还未完成）。接下来主程序暂停 3 秒，然后判断 future2 的 done() 方法，如果此时该任务已经完成，那么该方法将会返回 True。 程序最后通过 Future 的 result() 方法来获取两个异步任务返回的结果。 当程序使用 Future 的 result() 方法来获取结果时，该方法会阻塞当前线程，如果没有指定 timeout 参数，当前线程将一直处于阻塞状态，直到 Future 代表的任务返回。 获取执行结果前面程序调用了 Future 的 result() 方法来获取线程任务的运回值，但该方法会阻塞当前主线程，只有等到钱程任务完成后，result() 方法的阻塞才会被解除。 如果程序不希望直接调用 result() 方法阻塞线程，则可通过 Future 的 add_done_callback() 方法来添加回调函数，该回调函数形如 fn(future)。当线程任务完成后，程序会自动触发该回调函数，并将对应的 Future 对象作为参数传给该回调函数。 下面程序使用 add_done_callback() 方法来获取线程任务的返回值： 123456789101112131415161718192021222324from concurrent.futures import ThreadPoolExecutorimport threadingimport time# 定义一个准备作为线程任务的函数def action(max): my_sum = 0 for i in range(max): print(threading.current_thread().name + &#x27; &#x27; + str(i)) my_sum += i return my_sum# 创建一个包含2条线程的线程池with ThreadPoolExecutor(max_workers=2) as pool: # 向线程池提交一个task, 50会作为action()函数的参数 future1 = pool.submit(action, 50) # 向线程池再提交一个task, 100会作为action()函数的参数 future2 = pool.submit(action, 100) def get_result(future): print(future.result()) # 为future1添加线程完成的回调函数 future1.add_done_callback(get_result) # 为future2添加线程完成的回调函数 future2.add_done_callback(get_result) print(&#x27;--------------&#x27;) 上面主程序分别为 future1、future2 添加了同一个回调函数，该回调函数会在线程任务结束时获取其返回值。 主程序的最后一行代码打印了一条横线。由于程序并未直接调用 future1、future2 的 result() 方法，因此主线程不会被阻塞，可以立即看到输出主线程打印出的横线。接下来将会看到两个新线程并发执行，当线程任务执行完成后，get_result() 函数被触发，输出线程任务的返回值。 另外，由于线程池实现了上下文管理协议（Context Manage Protocol），因此，程序可以使用 with 语句来管理线程池，这样即可避免手动关闭线程池，如上面的程序所示。 此外，Exectuor 还提供了一个 map(func, *iterables, timeout&#x3D;None, chunksize&#x3D;1) 方法，该方法的功能类似于全局函数 map()，区别在于线程池的 map() 方法会为 iterables 的每个元素启动一个线程，以并发方式来执行 func 函数。这种方式相当于启动 len(iterables) 个线程，井收集每个线程的执行结果。 例如，如下程序使用 Executor 的 map() 方法来启动线程，并收集线程任务的返回值： 123456789101112131415161718from concurrent.futures import ThreadPoolExecutorimport threadingimport time# 定义一个准备作为线程任务的函数def action(max): my_sum = 0 for i in range(max): print(threading.current_thread().name + &#x27; &#x27; + str(i)) my_sum += i return my_sum# 创建一个包含4条线程的线程池with ThreadPoolExecutor(max_workers=4) as pool: # 使用线程执行map计算 # 后面元组有3个元素，因此程序启动3条线程来执行action函数 results = pool.map(action, (50, 100, 150)) print(&#x27;--------------&#x27;) for r in results: print(r) 上面程序使用 map() 方法来启动 3 个线程（该程序的线程池包含 4 个线程，如果继续使用只包含两个线程的线程池，此时将有一个任务处于等待状态，必须等其中一个任务完成，线程空闲出来才会获得执行的机会），map() 方法的返回值将会收集每个线程任务的返回结果。 运行上面程序，同样可以看到 3 个线程并发执行的结果，最后通过 results 可以看到 3 个线程任务的返回结果。 通过上面程序可以看出，使用 map() 方法来启动线程，并收集线程的执行结果，不仅具有代码简单的优点，而且虽然程序会以并发方式来执行 action() 函数，但最后收集的 action() 函数的执行结果，依然与传入参数的结果保持一致。也就是说，上面 results 的第一个元素是 action(50) 的结果，第二个元素是 action(100) 的结果，第三个元素是 action(150) 的结果。 请博主喝杯茶吧 ←———-请点击","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"}]},{"title":"如何用python实现自动下载自己想要的图片?","slug":"如何用python实现自动下载自己想要的图片","date":"2022-08-12T06:14:48.000Z","updated":"2022-08-12T06:37:45.725Z","comments":true,"path":"lxb/dcf0004f.html","link":"","permalink":"https://renjunda.ren/lxb/dcf0004f.html","excerpt":"","text":"关于python爬虫的优点——支持模块多、代码简洁、开发效率高 ，是我们进行网络爬虫可以选取的好工具。对于一个个的爬取下载，势必会消耗我们大量的时间，使用Python爬虫就可以解决这个问题，即可以实现自动下载。本文向大家介绍python爬虫的实战练习之进行自动下载图片的爬取过程。 自动下载图片流程 总结网址规律，以便根据网址访问网页； 根据网址规律，循环爬取并返回网页； 利用正则表达式提取并返回图片; 爬取案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding:utf8 -*-&#x27;&#x27;&#x27; 功能介绍： 利用爬虫实现图片爬取,输入你想检索的图片调用百度图片api实现检索,并下载文件&#x27;&#x27;&#x27;import requestsimport refrom urllib import parseimport osclass BaiduImageSpider(object): def __init__(self): self.url = &#x27;https://image.baidu.com/search/flip?tn=baiduimage&amp;word=&#123;&#125;&#x27; self.headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/4.0&#x27;&#125; # 获取图片 def get_image(self, url, word): # 使用 requests模块得到响应对象 res = requests.get(url, headers=self.headers) # 更改编码格式 res.encoding = &quot;utf-8&quot; # 得到html网页 html = res.text print(html) # 正则解析 pattern = re.compile(&#x27;&quot;hoverURL&quot;:&quot;(.*?)&quot;&#x27;, re.S) img_link_list = pattern.findall(html) # 存储图片的url链接 print(img_link_list) # 创建目录，用于保存图片 directory = &#x27;D:/study_folder/download/&#123;&#125;/&#x27;.format(word) # 如果目录不存在则创建，此方法常用 if not os.path.exists(directory): os.makedirs(directory) # 添加计数 i = 1 for img_link in img_link_list: filename = &#x27;&#123;&#125;&#123;&#125;.jpg&#x27;.format(directory, i) self.save_image(img_link, filename) i += 1 # 下载图片 def save_image(self, img_link, filename): html = requests.get(url=img_link, headers=self.headers).content with open(filename, &#x27;wb&#x27;) as f: f.write(html) print(filename, &#x27;下载成功&#x27;) # 入口函数 def run(self): word = input(&quot;您想要谁的照片:&quot;) word_parse = parse.quote(word) url = self.url.format(word_parse) self.get_image(url, word)if __name__ == &#x27;__main__&#x27;: spider = BaiduImageSpider() spider.run() 以上就是使用Python爬虫实现自动下载图片的过程，为了解放我们的双手，大家赶快练习起来哦~学会以后还可以往更深层次学呢，爬虫可不止是只能自动下载图片哦！","categories":[],"tags":[]},{"title":"函数内的ajax同步请求导致遮罩层失效、或者导致loading正在加载提示失效问题","slug":"ajax同步执行弹出层执行顺序混乱","date":"2022-08-02T05:57:35.000Z","updated":"2022-10-04T14:15:34.679Z","comments":true,"path":"lxb/416dd1e7.html","link":"","permalink":"https://renjunda.ren/lxb/416dd1e7.html","excerpt":"","text":"功能需求编写点击按钮，弹出loading遮罩层提示正在加载中…，同时查询后台信息，拼接数据后渲染到列表时，为了保障渲染时，列表中的数据已经拼接完成。所以在for循环中使用同步ajax进行请求，在success方法中进行拼接。 1234567891011121314151617181920212223function showPrintJobList()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); for(var i = 0;i &lt; rwid.length;i++)&#123; $.ajax(&#123; url: xxxxx, async: false, //默认异步，为保证数据完整和顺序使用同步请求 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //.....循环拼接结果，弹窗显示列表:$(&#x27;#rwlist&#x27;).show(); &#125;, error: function(err)&#123; console.log(err); &#125; &#125;); &#125; loadingTip.hide(); $(&#x27;#rwlist&#x27;).show();&#125; 问题信息点击按钮后，遮罩层没有弹出，而是等待表单渲染完成后，看到一闪而过的遮罩层。 问题原因async: falseajax同步请求在运行的时候，浏览器的UI、Dom元素渲染会被阻塞。所以当点击事件触发showPrintJobList函数时，loading.show()是有被加载到浏览器的js运行线程中，但是运行到ajax同步请求时，会将loading.show()阻塞执行，等到同步ajax请求完了，才会运行。然后同步ajax已经请求完了，然后直接被隐藏，然后显示列表。所以会看到一闪而过的loading遮罩层 解决方法一、使用async wait关键字二、使用JQuery的Deferred对象和$.when().done().fail() async&#x2F;await关键字 1.标识所修饰的函数存在异步代码，函数内部可用await关键字修饰异步过程变为同步。函数内部也可以全部为同步代码。2.非阻塞：async所标识的函数内存在异步代码，会等待异步代码执行完，但是async函数本身会马上返回，不会阻塞当前js工作主线程，可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回； 代码修改如下： 1234567891011121314151617181920212223async function showPrintJobList()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); for(var i = 0;i &lt; rwid.length;i++)&#123; await $.ajax(&#123; //使用await关键字修饰异步请求，保证数据顺序完整 url: xxxxx, async: true, //有await关键字，ajax请求修改为异步 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //.....循环拼接结果，弹窗显示列表:$(&#x27;#rwlist&#x27;).show(); &#125;, error: function(err)&#123; console.log(err); &#125; &#125;); &#125; loadingTip.hide(); $(&#x27;#rwlist&#x27;).show();&#125; 或者使用JQuery的Deferred对象和$.when().done().fail()使异步请求同步执行，同时不阻塞主线程。 123456789101112131415161718192021222324252627282930313233343536var dataList = [];function showPrintJobList()&#123; var defer = $.Deferred(); for(var i = 0;i &lt; rwid.length;i++)&#123; $.ajax(&#123; url: xxxxx, async: true, //使用Deferred对象，ajax请求修改为异步 type: &#x27;POST&#x27;, data:&#123; xxx: xxx &#125;, dataType: &#x27;json&#x27;, success: function(result) &#123; //dataList保存结果 dataList.push(result); defer.resolve(dataList); &#125;, error: function(err)&#123; defer.reject(err); &#125; &#125;); &#125; return defer;&#125;$(&#x27;button#showList&#x27;).click(function()&#123; var loadingTip = $(&#x27;#loading&#x27;); loadingTip.show(); $.when(showPrintJobList()).done(function(data)&#123; //循环拼接data中的list中的数据 loadingTip.hide(); $(&#x27;#rwlist&#x27;).show(); &#125;).fail(function()&#123; console.log(err); &#125;);&#125; 原理解析浏览器中一般会运行UI线程、JS线程以及事件触发线程。在上述上述代码中，loading.show()方法涉及到dom树的更新，所以被加载到了UI线程执行任务中。但是后面的ajax同步请求，因为不是异步的所以浏览器不会重新新增一个线程进行请求，而是直接放在js线程中阻塞其他线程执行。所以UI线程不能执行loading.show()方法。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"}]},{"title":"linux常用命令","slug":"linux常用命令/linux常用命令","date":"2022-07-15T08:00:00.000Z","updated":"2022-07-28T02:44:44.020Z","comments":true,"path":"lxb/fe4ef317.html","link":"","permalink":"https://renjunda.ren/lxb/fe4ef317.html","excerpt":"","text":"Linux随着IT产业的不断发展，Linux操作系统应用领域越来越广泛，尤其是近年来Linux在服务器领域飞速的发展，主要得益于Linux操作系统具备的如下优点 开源免费、系统迭代更新 系统性能稳定、安全性高 多任务、多用户 耗资源小、无需图形化界面、内核小 应用领域广泛、使用及入门容易 Linux命令cd12345目录切换cd .. # 上一层目录cd # 家目录cd ~ # 家目录cd / # 根目录 ls12345浏览目录下的文件或文件夹 ls -a # 列举所有文件或目录，包含.开头的隐藏文件 ls -l # 详细信息列举文件或目录 ls -i # 列出每个文件的Inode号 ls -t # 根据修改时间列出文件 pwd1显示当前所在的目录 mkdir123创建目录mkdir a # 创建a目录mkdir -p a/b/c # 递归创建目录 rm1234删除文件或目录rm a # 删除a文件rm -r a # 删除a目录rm -rf a # 强制删除a文件，不提示确认 cpcp 参数说明 -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。123拷贝文件或文件夹cp /root/1.py /home/1.py # 拷贝文件至新目录下cp -r 表示递归创建 cp -r 实例使用指令 cp 将当前目录 test&#x2F; 下的所有文件复制到新目录 newtest 下，输入如下命令： cp –r test&#x2F; newtest touch12创建普通文件touch 1.py # 创建1.py文件 cat1234查看文件内容cat /etc/redis/redis.conf # 查看redis.conf文件cat -n # 对输出所有行进行编号cat -b # 对输出非空行进行编号 cat1234查看文件内容cat /etc/redis/redis.conf # 查看redis.conf文件cat -n # 对输出所有行进行编号cat -b # 对输出非空行进行编号 less123如果文件较大的话，例如日志文件,我们想查看这个文件用cat命令肯定是不行的,less 命令可以精确到你想要查看的行号less -N + 行号 g run.log注意： -N是为了显示行号 head1234查看文件头部内容，通常为十行head -3 /etc/memcached.conf # 查看前三行head -n 100 # 查看前100行head -c 3 # 查看前三字节 tail1234查看文件末尾内容，通常为十行tail -n 3 1.txt # 查看后3行tail -f # 阻塞并即使输出文件变化后追加的数据用tail -f 监控日志日文件很方便,一定程度上可以提升开发效率 df123磁盘信息查询df -h # 查询磁盘使用量df -i # 分区Inode使用量 du12查看文件大小du -h 1.txt # 查看1.txt文件大小 echo1234打印或输出内容echo &#x27;hello&#x27; # 输出helloecho &#x27;hello&#x27; &gt; 1.md # 以hello内容覆盖1.mdecho &#x27;hello&#x27; &gt;&gt; 1.md # 以hello追加至1.md文件中 tar12345解压或压缩文件tar -jxvf # 解压bz2属性的压缩包tar -zxvf # 解压gz属性的压缩包tar -czvf # 使用gzip格式压缩文件tar -cjvf # 使用bzip2格式压缩文件 top1234567891011查看cpu使用率、内存使用率Processes: 602 total, 3 running, 599 sleeping, 3328 threads 10:28:56Load Avg: 2.28, 2.59, 2.93 CPU usage: 2.9% user, 2.3% sys, 95.87% idleSharedLibs: 433M resident, 88M data, 120M linkedit.MemRegions: 183414 total, 5692M resident, 133M private, 1890M shared.PhysMem: 16G used (3203M wired), 57M unused.VM: 20T vsize, 3083M framework vsize, 210327729(698) swapins, 212927606(0) swapouts.Networks: packets: 12467515/57G in, 10837863/53G out.Disks: 13084346/899G read, 9903101/930G written.PID COMMAND %CPU TIME #TH #WQ #PORT MEM PURG CMPRS PGRP PPID STATE free12345free -h查看内存，并以人性化方式展示[iomt@pa_cicd ~]$ free -h total used free shared buff/cache availableMem: 15G 1.1G 12G 313M 2.4G 13GSwap: 2.0G 0B 2.0G iostat1查看磁盘io读取速度 ps12查看进程ps -ef | grep process name su12切换账号su root # 切换为root用户 passwd1修改密码 rename1234567891011批量修改文件名称 &gt;[root@localhost kervin24]# ls a c fc.log ff.log fi.log fl.log fo.log fr.log fu.log fx.log aaa d fd.log fg.log fj.log fm.log fp.log fs.log fv.log fy.log b fb.log fe.log fh.log fk.log fn.log fq.log ft.log fw.log fz.log [root@localhost kervin24]# rename log txt * 把所有log文件改为txt文件 ------------------------------------------------------------------------------ [root@localhost kervin24]# ls a c fc.txt ff.txt fi.txt fl.txt fo.txt fr.txt fu.txt fx.txt aaa d fd.txt fg.txt fj.txt fm.txt fp.txt fs.txt fv.txt fy.txt b fb.txt fe.txt fh.txt fk.txt fn.txt fq.txt ft.txt fw.txt fz.txt","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://renjunda.ren/tags/Linux/"}]},{"title":"python详解paramiko","slug":"python详解paramiko/python详解paramiko","date":"2022-07-01T12:00:00.000Z","updated":"2022-07-28T02:44:26.154Z","comments":true,"path":"lxb/b2d1c38.html","link":"","permalink":"https://renjunda.ren/lxb/b2d1c38.html","excerpt":"","text":"paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。paramiko支持Linux, Solaris, BSD, MacOS X, Windows等平台通过SSH从一个平台连接到另外一个平台。利用该模块，可以方便的进行ssh连接和sftp协议进行sftp文件传输。 一、SSHClient类SSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装，该类封装了传输(Transport)，通道(Channel)及SFTPClient建立的方法(open_sftp)，通常用于执行远程命令。 ssh远程连接服务器 connet()1connect(ip, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False, sock=None, gss_auth=False, gss_kex=False, gss_deleg_creds=True, gss_host=None, banner_timeout=None, auth_timeout=None, gss_trust_dns=True, passphrase=None) 参数说明： ip(str类型)，连接的目标主机地址； port(int类型)，连接目标主机的端口，默认为22； username(str类型)，校验的用户名(默认为当前的本地用户名)； password(str类型)，密码用于身份校验或解锁私钥； pkey(Pkey类型)，私钥方式用于身份验证； key_filename(str or list(str)类型)，一个文件名或文件名列表，用于私钥的身份验证； timeout(float类型)，一个可选的超时时间(以秒为单位)的TCP连接； allow_agent(bool类型)，设置为False时用于禁用连接到SSH代理； look_for_keys(bool类型)，设置为False时用于来禁用在～&#x2F;.ssh中搜索私钥文件； compress(bool类型)，设置为True时打开压缩。 1234import paramikossh = paramiko.SSHClient()ssh.connect(ip,22,username,passwd,timeout=5)此处ip、username、passwd都作为变量 执行命令123456789101112131415import paramikoclient = paramiko.SSHClient()client.load_system_host_keys()# 目的是接受不在本地Known_host文件下的主机client.set_missing_host_key_policy(paramiko.AutoAddPolicy())# connect 函数可以接受很多参数client.connect(ip, port, txt_username, txt_password, timeout=5, allow_agent=False, look_for_keys=False)remote_conn = client.invoke_shell()time.sleep(3)# 实现当前目录下的东西remote_conn.send(&#x27;ls\\n&#x27;)# 获取命令的执行结果output = remote_conn.recv(2065535)# 关闭连接client.close()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"}]},{"title":"Mysql取消外键约束","slug":"Mysql取消外键约束","date":"2022-04-25T15:16:12.000Z","updated":"2022-04-28T10:16:36.488Z","comments":true,"path":"lxb/a03a2ff4.html","link":"","permalink":"https://renjunda.ren/lxb/a03a2ff4.html","excerpt":"","text":"SET FOREIGN_KEY_CHECKS&#x3D;0;在Mysql中取消外键约束Mysql中如果表和表之间建立的外键约束，则无法删除表及修改表结构 解决方法是在Mysql中取消外键约束: SET FOREIGN_KEY_CHECKS&#x3D;0; 然后将原来表的数据导出到sql语句，重新创建此表后，再把数据使用sql导入 然后再设置外键约束: SET FOREIGN_KEY_CHECKS&#x3D;1;","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://renjunda.ren/tags/Mysql/"}]},{"title":"使用chmod修改权限","slug":"使用chmod修改权限","date":"2022-04-21T08:16:12.000Z","updated":"2022-04-28T10:12:32.284Z","comments":true,"path":"lxb/26c8ee4c.html","link":"","permalink":"https://renjunda.ren/lxb/26c8ee4c.html","excerpt":"","text":"chmod简介12Chmod命令主要用于修改、设置文件权限chmod 修改文件权限主要有两种方式： 字母法与数字法 chmod能改变权限，-R是目录下所有文件，777就是高权限（读、写、执行）chmod -R 777 * 意思就是将当前目录下所有文件都给予777权限 1234567-rw------- （600) – 只有属主有读写权限。-rw-r–r-- (644) – 只有属主有读写权限；而属组用户和其他用户只有读权限。-rwx------ (700) – 只有属主有读、写、执行权限。-rwxr-xr-x (755) – 属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx–x–x (711) – 属主有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw-rw-rw- (666) – 所有用户都有文件读、写权限。这种做法不可取。-rwxrwxrwx (777) – 所有用户都有读、写、执行权限。更不可取的做法。 u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。u用户 g组 o其它 a 所有用户(默认) 表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 这个在服务器里不能随便敲的，不能在根目录下进行此命令，因为有些进程是指定权限（如755、700…）才能运行的…所以会出错.所以只需要指定自己所需的目录或文件进行赋予权限即可","categories":[],"tags":[]},{"title":"详解Python中的eval函数","slug":"详解Python中的eval函数","date":"2022-04-07T08:16:12.000Z","updated":"2022-04-08T03:39:53.752Z","comments":true,"path":"lxb/29f18618.html","link":"","permalink":"https://renjunda.ren/lxb/29f18618.html","excerpt":"","text":"在 Python 学习中如果能够利用好 Python 自带的函数，那么开发的速度将会出现事半功倍的效果。 一直以来关于 eval 函数的用法不是很清楚，毕竟这个函数在开发中出现的频率不算高。但是详细了解 eval 函数的用法，也是很重要的 实战教程 综上所述:eval函数的用法就是把字符串对象转换为能够具体的对象.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://renjunda.ren/tags/python/"}]},{"title":"Djano实现下载文件功能 (你没事吧?😁)","slug":"Djano实现下载文件功能/Djano实现下载文件功能","date":"2022-04-01T09:00:21.000Z","updated":"2022-04-02T01:12:18.838Z","comments":true,"path":"lxb/6c2328a8.html","link":"","permalink":"https://renjunda.ren/lxb/6c2328a8.html","excerpt":"","text":"一、简单介绍文件下载最简单的文件下载功能的实现 1、将文件流放入HttpResponse对象即可，如 12345def file_download(request): # do something... with open(&#x27;file_name.txt&#x27;) as f: c = f.read() return HttpResponse(c) 这种方式简单粗暴，适合小文件的下载，但如果这个文件非常大，这种方式会占用大量的内存，甚至导致服务器崩溃 更合理的文件下载功能Django的HttpResponse对象允许将迭代器作为传入参数，将上面代码中的传入参数c换成一个迭代器，便可以将上述下载功能优化为对大小文件均适合；而Django更进一步，推荐使StreamingHttpResponse对象取代HttpResponse对象，StreamingHttpResponse对象用于将文件流发送给浏览器，与HttpResponse对象非常相似，对于文件下载功能，使用StreamingHttpResponse对象更合理。 因此，更加合理的文件下载功能，应该先写一个迭代器，用于处理文件，然后将这个迭代器作为参数传递给StreaminghttpResponse对象 HttpResponse会直接使用迭代器对象，将迭代器对象的内容存储城字符串，然后返回给客户端，同时释放内存。可以当文件变大看出这是一个非常耗费时间和内存的过程。StreamingHttpResponse这是一种非常省时省内存的方法。但是因为StreamingHttpResponse的文件传输过程持续在整个response的过程中，所以这有可能会降低服务器的性能。 代码块 123456789101112131415from django.http import StreamingHttpResponse def file_download(request): def file_iterator(file_name, chunk_size=512): with open(file_name) as f: while True: c = f.read(chunk_size) if c: yield c else: break the_file_name = &quot;file_name.txt&quot; response = StreamingHttpResponse(file_iterator(the_file_name)) return response 结合项目使用完整示例代码如下，根据自己需求整改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 导入相关依赖文件import xlsxwriterfrom django.http import StreamingHttpResponse, JsonResponse, FileResponsefrom django.http import HttpResponsefrom django.urls import reverse_lazyfrom django.utils.encoding import escape_uri_pathdef export_data(request): filename = &#x27;&#123;&#125;.xlsx&#x27;.format(&#x27;人员信息&#x27;) if request.method == &#x27;GET&#x27;: try: response = StreamingHttpResponse(file_iterator(filename)) # 以流的形式下载文件,这样可以实现任意格式的文件下载 response[&#x27;Content-Type&#x27;] = &#x27;application/octet-stream&#x27; response[&quot;Content-Disposition&quot;] = &quot;attachment; filename*=UTF-8&#x27;&#x27;&#123;&#125;&quot;.format(escape_uri_path(filename)) except: return HttpResponse(&quot;生成文件失败&quot;) return response if request.method == &#x27;POST&#x27;: # 表头,为了方便直接再代码中, 平时我们为了规范代码一般写在配置文件中 ping_header = &#123; &#x27;姓名&#x27;: &#x27;1&#x27;, &#x27;性别&#x27;: &#x27;2&#x27;, &#x27;年龄&#x27;: &#x27;3&#x27;, &#x27;居住地址&#x27;: &#x27;4&#x27;, &#125; # 先把数据写死，根据需求自己去数据库查询 data = [ &#123;&#x27;name&#x27;: &#x27;刘备&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 18, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;关羽&#x27;, &#x27;sex&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;张飞&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;黄宇恒&#x27;, &#x27;sex&#x27;: &#x27;其他&#x27;, &#x27;age&#x27;: 99, &#x27;addr&#x27;: &#x27;江西省南昌市进贤县&#x27;&#125;, ] workbook = xlsxwriter.Workbook(filename) # 建立文件 worksheet = workbook.add_worksheet(&quot;人员信息统计&quot;) head_style = workbook.add_format(xlsx_style(bold=True, bg_color=&#x27;#95B3D7&#x27;)) body_style = workbook.add_format(xlsx_style()) _header = ping_header for index, value in enumerate(_header): worksheet.write(0, index + 4, value, head_style) n_index = 1 if len(data) &gt; 0: for item in data: worksheet.write(n_index, 4, item[&#x27;name&#x27;] if item.get(&#x27;name&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 5, item[&#x27;sex&#x27;] if item.get(&#x27;sex&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 6, item[&#x27;age&#x27;] if item.get(&#x27;age&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 7, item[&#x27;addr&#x27;] if item.get(&#x27;addr&#x27;) else &#x27;&#x27;, body_style) n_index += 1 # 将生成的excel放入byte流给response workbook.close() url = reverse_lazy(&#x27;app_name:路由名称&#x27;) # 将下载路由返回前端,前端通过请求返回的路由实现文件下载 return JsonResponse(&#123;&#x27;redirect&#x27;: url, &#x27;code&#x27;: 0&#125;)def file_iterator(file_path, chunk_size=512): &quot;&quot;&quot; 文件生成器,防止文件过大，导致内存溢出 :param file_path: 文件路径 :param chunk_size: 块大小 :return: 生成器 &quot;&quot;&quot; with open(file_path, mode=&#x27;rb&#x27;) as f: while True: c = f.read(chunk_size) if c: yield c else: break# xlsxwriter的样式公有函数def xlsx_style(**kwargs): style = &#123; &#x27;bold&#x27;: kwargs.get(&#x27;bold&#x27;, False), # 加粗 &#x27;font_name&#x27;: kwargs.get(&#x27;font_name&#x27;, &#x27;SimSun&#x27;), # 字体类型，默认宋体 &#x27;font_size&#x27;: kwargs.get(&#x27;font_size&#x27;, 10), # 字体大小，默认12 &#x27;font_color&#x27;: kwargs.get(&#x27;font_color&#x27;, &#x27;#000000&#x27;), # 字体颜色，黑色 &#x27;align&#x27;: kwargs.get(&#x27;align&#x27;, &#x27;center&#x27;), # 默认水平居中 &#x27;valign&#x27;: kwargs.get(&#x27;valign&#x27;, &#x27;vcenter&#x27;), # 默认垂直居中 &#x27;text_wrap&#x27;: kwargs.get(&#x27;text_wrap&#x27;, True), # 默认自动换行 &#x27;top&#x27;: kwargs.get(&#x27;top&#x27;, 1), # 上边界，线条宽度 &#x27;bottom&#x27;: kwargs.get(&#x27;bottom&#x27;, 1), # 边界 &#x27;left&#x27;: kwargs.get(&#x27;left&#x27;, 1), # 边界 &#x27;right&#x27;: kwargs.get(&#x27;right&#x27;, 1), # 边界 &#x27;bg_color&#x27;: kwargs.get(&#x27;bg_color&#x27;, &#x27;#FFFFFF&#x27;), # 背景颜色，白色 # 其他类型设置格式可以接着写 &#125; return style 文件下载完成后样式展示","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"js如何获取url中的参数","slug":"js如何获取url中的参数/js如何获取url中的参数","date":"2022-04-01T08:24:09.000Z","updated":"2022-04-02T01:10:09.079Z","comments":true,"path":"lxb/5477648b.html","link":"","permalink":"https://renjunda.ren/lxb/5477648b.html","excerpt":"","text":"js如何通过代码获取url中的参数, 以下函数是获取url中参数的公有方法, 直接使用即可123456789101112131415161718function getRequest() &#123; var url = window.location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; //就是这句的问题 theRequest[strs[i].split(&quot;=&quot;)[0]]=decodeURI(strs[i].split(&quot;=&quot;)[1]); //之前用了unescape() //才会出现乱码 &#125; &#125; return theRequest; &#125; var arr = getRequest(); var name = arr[&#x27;name&#x27;]; // url中的参数名称 var time = arr[&#x27;time&#x27;];","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"}]},{"title":"WebSocket连接失败，报错400","slug":"WebSocket连接失败，报错400/WebSocket连接失败，报错400","date":"2022-04-01T08:09:17.000Z","updated":"2022-04-01T08:21:19.994Z","comments":true,"path":"lxb/14b1fd40.html","link":"","permalink":"https://renjunda.ren/lxb/14b1fd40.html","excerpt":"","text":"WebSocket 连接失败，报错400 WebSocket握手期间出错，响应码：400。出现原因：可能你的应用程序版本低于nginx 我的解决方式：告诉nginx在和服务端通信的时候，使用http&#x2F;1.1，并且Nginx当想要使用WebSocket时由浏览器通过HTTP发起的Upgrade请求做出响应。即：在nginx的配置文件中，修改对应的websocket代理服务。如图： 修改完配置还需要再Django项目中的settings中配置websocket 1WEBSOCKET_FACTORY_CLASS = &#x27;dwebsocket.backends.uwsgi.factory.uWsgiWebSocketFactory&#x27; 最后重启nginx&amp;项目","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"}]},{"title":"layui弹出层时间控件闪退解决方案","slug":"layui弹出层时间控件闪退解决方案","date":"2021-04-01T07:53:58.000Z","updated":"2022-04-01T08:06:18.108Z","comments":true,"path":"lxb/d2cfb4a5.html","link":"","permalink":"https://renjunda.ren/lxb/d2cfb4a5.html","excerpt":"","text":"使用layui时间组件有闪退问题,只需要在实例化时添加点击事件问题就可以解决了,具体配置如下123456laydate.render(&#123; elem: &#x27;&#x27;, range: &#x27;到&#x27;, type: &#x27;datetime&#x27;, trigger: &#x27;click&#x27;, # 新增点击事件 &#125;);","categories":[],"tags":[{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"}]},{"title":"Django模糊查询和查询操作","slug":"Django模糊查询和查询操作","date":"2021-03-23T05:59:08.000Z","updated":"2022-03-30T10:00:02.501Z","comments":true,"path":"lxb/undefined.html","link":"","permalink":"https://renjunda.ren/lxb/undefined.html","excerpt":"","text":"Django ORM 模糊查询和查询操作queryset中支持链式操作12book=Book.objects.all().order_by(&#x27;-nid&#x27;).first()只要返回的是queryset对象就可以调用其他的方法,直到返回的是对象本身 模糊查询常用的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344大于、大于等于:__gt 大于&gt;__gte 大于等于&gt;=Student.objects.filter(age__gt=10) // 查询年龄大于10岁的学生Student.objects.filter(age__gte=10) // 查询年龄大于等于10岁的学生like:__exact 精确等于 like &#x27;aaa&#x27;__iexact 精确等于 忽略大小写 ilike &#x27;aaa&#x27;__contains 包含 like &#x27;%aaa%&#x27;__icontains 包含,忽略大小写 ilike &#x27;%aaa%&#x27;，但是对于sqlite来说，contains的作用效果等同于icontainsin:__in查询年龄在某一范围的学生Student.objects.filter(age__in=[10, 20, 30])is null / is not nullStudent.objects.filter(name__isnull=True) // 查询用户名为空的学生Student.objects.filter(name__isnull=False) // 查询用户名不为空的学生不等于/不包含于：Student.objects.filter().excute(age=10) // 查询年龄不为10的学生Student.objects.filter().excute(age__in=[10, 20]) // 查询年龄不在 [10, 20] 的学生其他常用模糊查询：__startswith 以…开头__istartswith 以…开头 忽略大小写__endswith 以…结尾__iendswith 以…结尾，忽略大小写__range 在…范围内__year 日期字段的年份__month 日期字段的月份__day 日期字段的日Book.objects.filter(create_time__year=2019, create_time__month=4).all()","categories":[],"tags":[]},{"title":"怎样实现图片验证码","slug":"怎样实现图片验证码","date":"2020-05-31T06:22:05.000Z","updated":"2022-04-02T07:35:15.805Z","comments":true,"path":"lxb/49696.html","link":"","permalink":"https://renjunda.ren/lxb/49696.html","excerpt":"","text":"利用django + vue实现图片验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import uuidimport randomfrom captcha.image import ImageCaptchafrom io import BytesIOimport redis# 创建redis实例r = redis.Redis(host=&#x27;127.0.0.1&#x27;, port=6379, password=&#x27;&#x27;,decode_responses=True)# 封装一个函数,此函数用于生成图片验证码中的数字或字母def random_code(num=4): # num 是生成随机的数量 默认为4 str__a_z = [chr(num) for num in range(97, 123)] str__A_Z = [chr(num) for num in range(65, 91)] num_0_9 = [str(num) for num in range(0, 10)] return &#x27;&#x27;.join(random.sample(str__a_z + str__A_Z + num_0_9, num))# 此函数用于生成图片def make_verify_image(code_str, uuid=None): # 保存验证码到redis中,并且设置过期时间 r.set(uuid, code_str, 60) # 生成验证码图片 img = ImageCaptcha().generate_image(code_str) # 图片不会永久存储，只需要在内存中存储即可 # 把Image对象写入到IO流中 out = BytesIO() # 文件流对象打开在内存中 img.save(out, &#x27;jpeg&#x27;) return out.getvalue()# vue代码 generate_image_code() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, UUId() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, jc() &#123; axios(&#123; url:this.base_url + &#x27;userapp/xy/&#x27;, method:&#x27;post&#x27;, data:&#123;&#x27;uuid&#x27;:this.uuid,&#x27;code&#x27;:this.check&#125; &#125;).then(res=&gt;&#123; console.log(res.data) if(res.data.code == 200) &#123; this.check_img = true this.error_image_code = res.data.msg &#125; if(res.data.code==500) &#123; this.check_img = false this.error_image_code = res.data.msg &#125; &#125;) &#125;,class GenerateUUID(APIView): def get(self, request): # 注册页面 挂载时请求接口 返回一个uuid rt = random_code() # print(rt) return Response(str(uuid.uuid1()))class Generateimg(APIView): &#x27;&#x27;&#x27; 返回前端验证码图片 &#x27;&#x27;&#x27; def get(self, request, uuid): # 2.创建随机数 code = random_code() # 3.生成验证码图片 image = make_verify_image(code, uuid) # 4.返回图片 return HttpResponse(image, content_type=&#x27;image/jpeg&#x27;)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"怎样设置flask后台管理","slug":"怎样设置flask后台管理","date":"2019-06-03T02:44:47.000Z","updated":"2022-04-08T03:39:59.325Z","comments":true,"path":"lxb/25760.html","link":"","permalink":"https://renjunda.ren/lxb/25760.html","excerpt":"","text":"快速开发后台flask-admin Flask-admin也是有局限性的,他只适合开发小型快速应用,不适合那种大型并发性高,逻辑复杂的应用. 首先,对于大型应用都是前后端分离的,加快访问速度,而且后端装配,尤其是这种动态生成的速度更慢 流程介绍1234567891011121314# 导入admin扩展包from flask_admin import Admin# 创建实例对象 这里的name就是后台的标题admin = Admin(app, name=&#x27;管理后台&#x27;, template_mode=&#x27;bootstrap3&#x27;) # 导入ModelViewfrom flask_admin.contrib.sqla import ModelView# 注册model public是声明的model类名 db.session,是在config中声明的数据库连接 name是小标题admin.add_view(ModelView(public, db.session,name=&#x27;test&#x27;))# 汉化 引入Flask-BabeIExfrom flask_babelex import Babelbabel = Babel(app)app.config[&#x27;BABEL_DEFAULT_LOCALE&#x27;] = &#x27;zh_CN&#x27; 大功告成!!","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]},{"title":"部署时django没有样式解决方案","slug":"部署时django没有样式解决方案","date":"2018-08-01T00:08:09.000Z","updated":"2022-04-02T07:44:04.381Z","comments":true,"path":"lxb/17098.html","link":"","permalink":"https://renjunda.ren/lxb/17098.html","excerpt":"","text":"我们在服务器上部署自己的项目时,发现django没有样式,这时我们需要收集静态资源来进行解决. 在项目中创建一个static文件夹 在settings中添加以下配置: 1STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;) 然后在nginx配置中添加 123location /static/ &#123; root /home/myproject/WorkerOrder; # 项目的绝对路径&#125; 配置完成后执行python manage.py collectstatic 重新启动nginx完毕","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://renjunda.ren/tags/Python/"},{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"},{"name":"Linux","slug":"Linux","permalink":"https://renjunda.ren/tags/Linux/"},{"name":"Mysql","slug":"Mysql","permalink":"https://renjunda.ren/tags/Mysql/"},{"name":"python","slug":"python","permalink":"https://renjunda.ren/tags/python/"},{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"},{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"},{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"},{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]}