{"meta":{"title":"任俊达-技术博客","subtitle":"","description":"","author":"任俊达","url":"https://renjunda.ren","root":"/"},"pages":[{"title":"BuyMeTea","date":"2002-04-01T01:23:02.000Z","updated":"2022-04-01T01:34:20.789Z","comments":true,"path":"money.html","permalink":"https://renjunda.ren/money.html","excerpt":"","text":"请我喝茶"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-03-31T09:32:27.103Z","comments":true,"path":"about.html","permalink":"https://renjunda.ren/about.html","excerpt":"","text":"我的画像我是不理性的、懒惰的、仅凭热爱驱动的、偏执的、信仰科学的、喜欢探索的、热爱生命的、向往阳光的。 我听的音乐细腰婆姨 - 用户 - 网易云音乐(163.com)"},{"title":"about","date":"2021-03-31T03:44:31.000Z","updated":"2022-03-31T09:48:50.271Z","comments":true,"path":"PY.html","permalink":"https://renjunda.ren/PY.html","excerpt":"","text":"我们会慢慢长大成人，随着季节的不停变换路边盛开的鲜花也在不断变化，那个季节盛开的鲜花到底叫什么名字，轻轻摇曳着一旦触摸它就会轻轻地被扎到，用鼻子靠近闻一闻，会有一股淡淡的青涩太阳的芳香，随着那股香味慢慢变淡我们也在长大成人，但是那朵花一定会在某处继续盛开。 我的朋友"}],"posts":[{"title":"Djano实现下载文件功能","slug":"Djano实现下载文件功能/Djano实现下载文件功能","date":"2022-04-01T09:00:21.000Z","updated":"2022-04-01T09:15:12.402Z","comments":true,"path":"lxb/6c2328a8.html","link":"","permalink":"https://renjunda.ren/lxb/6c2328a8.html","excerpt":"","text":"一、简单介绍文件下载最简单的文件下载功能的实现 1、将文件流放入HttpResponse对象即可，如 12345def file_download(request): # do something... with open(&#x27;file_name.txt&#x27;) as f: c = f.read() return HttpResponse(c) 这种方式简单粗暴，适合小文件的下载，但如果这个文件非常大，这种方式会占用大量的内存，甚至导致服务器崩溃 更合理的文件下载功能Django的HttpResponse对象允许将迭代器作为传入参数，将上面代码中的传入参数c换成一个迭代器，便可以将上述下载功能优化为对大小文件均适合；而Django更进一步，推荐使StreamingHttpResponse对象取代HttpResponse对象，StreamingHttpResponse对象用于将文件流发送给浏览器，与HttpResponse对象非常相似，对于文件下载功能，使用StreamingHttpResponse对象更合理。 因此，更加合理的文件下载功能，应该先写一个迭代器，用于处理文件，然后将这个迭代器作为参数传递给StreaminghttpResponse对象 HttpResponse会直接使用迭代器对象，将迭代器对象的内容存储城字符串，然后返回给客户端，同时释放内存。可以当文件变大看出这是一个非常耗费时间和内存的过程。StreamingHttpResponse这是一种非常省时省内存的方法。但是因为StreamingHttpResponse的文件传输过程持续在整个response的过程中，所以这有可能会降低服务器的性能。 代码块 123456789101112131415from django.http import StreamingHttpResponse def file_download(request): def file_iterator(file_name, chunk_size=512): with open(file_name) as f: while True: c = f.read(chunk_size) if c: yield c else: break the_file_name = &quot;file_name.txt&quot; response = StreamingHttpResponse(file_iterator(the_file_name)) return response 结合项目使用完整示例代码如下，根据自己需求整改1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 导入相关依赖文件import xlsxwriterfrom django.http import StreamingHttpResponse, JsonResponse, FileResponsefrom django.http import HttpResponsefrom django.urls import reverse_lazyfrom django.utils.encoding import escape_uri_pathdef export_data(request): filename = &#x27;&#123;&#125;.xlsx&#x27;.format(&#x27;人员信息&#x27;) if request.method == &#x27;GET&#x27;: try: response = StreamingHttpResponse(file_iterator(filename)) # 以流的形式下载文件,这样可以实现任意格式的文件下载 response[&#x27;Content-Type&#x27;] = &#x27;application/octet-stream&#x27; response[&quot;Content-Disposition&quot;] = &quot;attachment; filename*=UTF-8&#x27;&#x27;&#123;&#125;&quot;.format(escape_uri_path(filename)) except: return HttpResponse(&quot;生成文件失败&quot;) return response if request.method == &#x27;POST&#x27;: # 表头,为了方便直接再代码中, 平时我们为了规范代码一般写在配置文件中 ping_header = &#123; &#x27;姓名&#x27;: &#x27;1&#x27;, &#x27;性别&#x27;: &#x27;2&#x27;, &#x27;年龄&#x27;: &#x27;3&#x27;, &#x27;居住地址&#x27;: &#x27;4&#x27;, &#125; # 先把数据写死，根据需求自己去数据库查询 data = [ &#123;&#x27;name&#x27;: &#x27;刘备&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 18, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;关羽&#x27;, &#x27;sex&#x27;: &#x27;女&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;张飞&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 10, &#x27;addr&#x27;: &#x27;荆州&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;黄宇恒&#x27;, &#x27;sex&#x27;: &#x27;其他&#x27;, &#x27;age&#x27;: 99, &#x27;addr&#x27;: &#x27;江西省南昌市进贤县&#x27;&#125;, ] workbook = xlsxwriter.Workbook(filename) # 建立文件 worksheet = workbook.add_worksheet(&quot;人员信息统计&quot;) head_style = workbook.add_format(xlsx_style(bold=True, bg_color=&#x27;#95B3D7&#x27;)) body_style = workbook.add_format(xlsx_style()) _header = ping_header for index, value in enumerate(_header): worksheet.write(0, index + 4, value, head_style) n_index = 1 if len(data) &gt; 0: for item in data: worksheet.write(n_index, 4, item[&#x27;name&#x27;] if item.get(&#x27;name&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 5, item[&#x27;sex&#x27;] if item.get(&#x27;sex&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 6, item[&#x27;age&#x27;] if item.get(&#x27;age&#x27;) else &#x27;&#x27;, body_style) worksheet.write(n_index, 7, item[&#x27;addr&#x27;] if item.get(&#x27;addr&#x27;) else &#x27;&#x27;, body_style) n_index += 1 # 将生成的excel放入byte流给response workbook.close() url = reverse_lazy(&#x27;app_name:路由名称&#x27;) # 将下载路由返回前端,前端通过请求返回的路由实现文件下载 return JsonResponse(&#123;&#x27;redirect&#x27;: url, &#x27;code&#x27;: 0&#125;)def file_iterator(file_path, chunk_size=512): &quot;&quot;&quot; 文件生成器,防止文件过大，导致内存溢出 :param file_path: 文件路径 :param chunk_size: 块大小 :return: 生成器 &quot;&quot;&quot; with open(file_path, mode=&#x27;rb&#x27;) as f: while True: c = f.read(chunk_size) if c: yield c else: break# xlsxwriter的样式公有函数def xlsx_style(**kwargs): style = &#123; &#x27;bold&#x27;: kwargs.get(&#x27;bold&#x27;, False), # 加粗 &#x27;font_name&#x27;: kwargs.get(&#x27;font_name&#x27;, &#x27;SimSun&#x27;), # 字体类型，默认宋体 &#x27;font_size&#x27;: kwargs.get(&#x27;font_size&#x27;, 10), # 字体大小，默认12 &#x27;font_color&#x27;: kwargs.get(&#x27;font_color&#x27;, &#x27;#000000&#x27;), # 字体颜色，黑色 &#x27;align&#x27;: kwargs.get(&#x27;align&#x27;, &#x27;center&#x27;), # 默认水平居中 &#x27;valign&#x27;: kwargs.get(&#x27;valign&#x27;, &#x27;vcenter&#x27;), # 默认垂直居中 &#x27;text_wrap&#x27;: kwargs.get(&#x27;text_wrap&#x27;, True), # 默认自动换行 &#x27;top&#x27;: kwargs.get(&#x27;top&#x27;, 1), # 上边界，线条宽度 &#x27;bottom&#x27;: kwargs.get(&#x27;bottom&#x27;, 1), # 边界 &#x27;left&#x27;: kwargs.get(&#x27;left&#x27;, 1), # 边界 &#x27;right&#x27;: kwargs.get(&#x27;right&#x27;, 1), # 边界 &#x27;bg_color&#x27;: kwargs.get(&#x27;bg_color&#x27;, &#x27;#FFFFFF&#x27;), # 背景颜色，白色 # 其他类型设置格式可以接着写 &#125; return style 文件下载完成后样式展示","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"js如何获取url中的参数","slug":"js如何获取url中的参数/js如何获取url中的参数","date":"2022-04-01T08:24:09.000Z","updated":"2022-04-01T08:31:02.011Z","comments":true,"path":"lxb/5477648b.html","link":"","permalink":"https://renjunda.ren/lxb/5477648b.html","excerpt":"","text":"js如何通过代码获取url中的参数, 以下函数时获取url中参数的公有方法, 直接使用即可123456789101112131415161718function getRequest() &#123; var url = window.location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; //就是这句的问题 theRequest[strs[i].split(&quot;=&quot;)[0]]=decodeURI(strs[i].split(&quot;=&quot;)[1]); //之前用了unescape() //才会出现乱码 &#125; &#125; return theRequest; &#125; var arr = getRequest(); var name = arr[&#x27;name&#x27;]; // url中的参数名称 var time = arr[&#x27;time&#x27;];","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"}]},{"title":"WebSocket连接失败，报错400","slug":"WebSocket连接失败，报错400/WebSocket连接失败，报错400","date":"2022-04-01T08:09:17.000Z","updated":"2022-04-01T08:21:19.994Z","comments":true,"path":"lxb/14b1fd40.html","link":"","permalink":"https://renjunda.ren/lxb/14b1fd40.html","excerpt":"","text":"WebSocket 连接失败，报错400 WebSocket握手期间出错，响应码：400。出现原因：可能你的应用程序版本低于nginx 我的解决方式：告诉nginx在和服务端通信的时候，使用http&#x2F;1.1，并且Nginx当想要使用WebSocket时由浏览器通过HTTP发起的Upgrade请求做出响应。即：在nginx的配置文件中，修改对应的websocket代理服务。如图： 修改完配置还需要再Django项目中的settings中配置websocket 1WEBSOCKET_FACTORY_CLASS = &#x27;dwebsocket.backends.uwsgi.factory.uWsgiWebSocketFactory&#x27; 最后重启nginx&amp;项目","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"}]},{"title":"layui弹出层时间控件闪退解决方案","slug":"layui弹出层时间控件闪退解决方案","date":"2021-04-01T07:53:58.000Z","updated":"2022-04-01T08:06:18.108Z","comments":true,"path":"lxb/d2cfb4a5.html","link":"","permalink":"https://renjunda.ren/lxb/d2cfb4a5.html","excerpt":"","text":"使用layui时间组件有闪退问题,只需要在实例化时添加点击事件问题就可以解决了,具体配置如下123456laydate.render(&#123; elem: &#x27;&#x27;, range: &#x27;到&#x27;, type: &#x27;datetime&#x27;, trigger: &#x27;click&#x27;, # 新增点击事件 &#125;);","categories":[],"tags":[{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"}]},{"title":"Django模糊查询和查询操作","slug":"Django模糊查询和查询操作","date":"2021-03-23T05:59:08.000Z","updated":"2022-03-30T10:00:02.501Z","comments":true,"path":"lxb/undefined.html","link":"","permalink":"https://renjunda.ren/lxb/undefined.html","excerpt":"","text":"Django ORM 模糊查询和查询操作queryset中支持链式操作12book=Book.objects.all().order_by(&#x27;-nid&#x27;).first()只要返回的是queryset对象就可以调用其他的方法,直到返回的是对象本身 模糊查询常用的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344大于、大于等于:__gt 大于&gt;__gte 大于等于&gt;=Student.objects.filter(age__gt=10) // 查询年龄大于10岁的学生Student.objects.filter(age__gte=10) // 查询年龄大于等于10岁的学生like:__exact 精确等于 like &#x27;aaa&#x27;__iexact 精确等于 忽略大小写 ilike &#x27;aaa&#x27;__contains 包含 like &#x27;%aaa%&#x27;__icontains 包含,忽略大小写 ilike &#x27;%aaa%&#x27;，但是对于sqlite来说，contains的作用效果等同于icontainsin:__in查询年龄在某一范围的学生Student.objects.filter(age__in=[10, 20, 30])is null / is not nullStudent.objects.filter(name__isnull=True) // 查询用户名为空的学生Student.objects.filter(name__isnull=False) // 查询用户名不为空的学生不等于/不包含于：Student.objects.filter().excute(age=10) // 查询年龄不为10的学生Student.objects.filter().excute(age__in=[10, 20]) // 查询年龄不在 [10, 20] 的学生其他常用模糊查询：__startswith 以…开头__istartswith 以…开头 忽略大小写__endswith 以…结尾__iendswith 以…结尾，忽略大小写__range 在…范围内__year 日期字段的年份__month 日期字段的月份__day 日期字段的日Book.objects.filter(create_time__year=2019, create_time__month=4).all()","categories":[],"tags":[]},{"title":"怎样实现图片验证码","slug":"怎样实现图片验证码","date":"2020-05-31T06:22:05.000Z","updated":"2022-03-31T09:36:00.792Z","comments":true,"path":"lxb/49696.html","link":"","permalink":"https://renjunda.ren/lxb/49696.html","excerpt":"","text":"利用django + vue实现图片验证码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import uuidimport randomfrom captcha.image import ImageCaptchafrom io import BytesIOimport redis# 创建redis实例r = redis.Redis(host=&#x27;127.0.0.1&#x27;, port=6379, password=&#x27;&#x27;,decode_responses=True)# 封装一个函数,此函数用于生成图片验证码中的数字或字母def random_code(num=4): # num 是生成随机的数量 默认为4 str__a_z = [chr(num) for num in range(97, 123)] str__A_Z = [chr(num) for num in range(65, 91)] num_0_9 = [str(num) for num in range(0, 10)] return &#x27;&#x27;.join(random.sample(str__a_z + str__A_Z + num_0_9, num))# 此函数用于生成图片def make_verify_image(code_str, uuid=None): # 保存验证码到redis中,并且设置过期时间 r.set(uuid, code_str, 60) # 生成验证码图片 img = ImageCaptcha().generate_image(code_str) # 图片不会永久存储，只需要在内存中存储即可 # 把Image对象写入到IO流中 out = BytesIO() # 文件流对象打开在内存中 img.save(out, &#x27;jpeg&#x27;) return out.getvalue()# vue代码 generate_image_code() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, UUId() &#123; axios(&#123; url:this.base_url + &#x27;userapp/uuid/&#x27;, &#125;).then(res=&gt;&#123; console.log(res.data) this.uuid = res.data this.image_code_url = this.base_url +&quot;userapp/&quot; + &#x27;tupian/&#x27; + this.uuid +&#x27;/&#x27; &#125;) &#125;, jc() &#123; axios(&#123; url:this.base_url + &#x27;userapp/xy/&#x27;, method:&#x27;post&#x27;, data:&#123;&#x27;uuid&#x27;:this.uuid,&#x27;code&#x27;:this.check&#125; &#125;).then(res=&gt;&#123; console.log(res.data) if(res.data.code == 200) &#123; this.check_img = true this.error_image_code = res.data.msg &#125; if(res.data.code==500) &#123; this.check_img = false this.error_image_code = res.data.msg &#125; &#125;) &#125;,class GenerateUUID(APIView): def get(self, request): # 注册页面 挂载时请求接口 返回一个uuid rt = random_code() # print(rt) return Response(str(uuid.uuid1()))class Generateimg(APIView): &#x27;&#x27;&#x27; 返回前端验证码图片 &#x27;&#x27;&#x27; def get(self, request, uuid): # 2.创建随机数 code = random_code() # 3.生成验证码图片 image = make_verify_image(code, uuid) # 4.返回图片 return HttpResponse(image, content_type=&#x27;image/jpeg&#x27;)","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"}]},{"title":"怎样设置flask后台管理","slug":"怎样设置flask后台管理","date":"2019-06-03T02:44:47.000Z","updated":"2022-03-31T09:36:03.409Z","comments":true,"path":"lxb/25760.html","link":"","permalink":"https://renjunda.ren/lxb/25760.html","excerpt":"","text":"快速开发后台flask-admin Flask-admin也是有局限性的,他只适合开发小型快速应用,不适合那种大型并发性高,逻辑复杂的应用. 首先,对于大型应用都是前后端分离的,加快访问速度,而且后端装配,尤其是这种动态生成的速度更慢 流程介绍1234567891011121314# 导入admin扩展包from flask_admin import Admin# 创建实例对象 这里的name就是后台的标题admin = Admin(app, name=&#x27;管理后台&#x27;, template_mode=&#x27;bootstrap3&#x27;) # 导入ModelViewfrom flask_admin.contrib.sqla import ModelView# 注册model public是声明的model类名 db.session,是在config中声明的数据库连接 name是小标题admin.add_view(ModelView(public, db.session,name=&#x27;test&#x27;))# 汉化 引入Flask-BabeIExfrom flask_babelex import Babelbabel = Babel(app)app.config[&#x27;BABEL_DEFAULT_LOCALE&#x27;] = &#x27;zh_CN&#x27; 大功告成!!","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]},{"title":"部署时django没有样式解决方案","slug":"部署时django没有样式解决方案","date":"2018-08-01T00:08:09.000Z","updated":"2022-03-31T09:36:07.451Z","comments":true,"path":"lxb/17098.html","link":"","permalink":"https://renjunda.ren/lxb/17098.html","excerpt":"","text":"我们在服务器上部署自己的项目时,发现django没有样式,这时我们需要收集静态资源来进行解决. 在项目中创建一个static文件夹 在settings中添加以下配置: 1STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;) 然后在nginx配置中添加 123location /static/ &#123; root /home/myproject/WorkerOrder; # 项目的绝对路径&#125; 配置完成后执行python manage.py collectstatic 重新启动nginx完毕","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"https://renjunda.ren/tags/Django/"},{"name":"js","slug":"js","permalink":"https://renjunda.ren/tags/js/"},{"name":"nginx","slug":"nginx","permalink":"https://renjunda.ren/tags/nginx/"},{"name":"layui","slug":"layui","permalink":"https://renjunda.ren/tags/layui/"},{"name":"Flask","slug":"Flask","permalink":"https://renjunda.ren/tags/Flask/"}]}